<?xml version="1.0" encoding="UTF-8"?><!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<spec xmlns:ex="http://expath.org/ns/xmlspec" role="editors-copy" ex:w3c="true">
   <header>
      <title>Archive Module</title>
      <w3c-designation>w3c-designation</w3c-designation>
      <w3c-doctype>EXPath Candidate Module</w3c-doctype>
      <pubdate>
         <day>26</day>
         <month>September</month>
         <year>2013</year>
      </pubdate>
      <publoc>
         <loc href="http://expath.org/spec/archive/20130926"/>
      </publoc>
      <altlocs>
         <loc href="http://expath.org/spec/archive/20130926.xml">XML</loc>
      </altlocs>
      <latestloc>
         <loc href="http://expath.org/spec/archive"/>
      </latestloc>

      <prevlocs>
         <loc href="http://expath.org/spec/zip/20101012"/>
      </prevlocs>

      <authlist>
         <author role="editor">
            <name>John Lumley</name>
            <affiliation>Saxonica Ltd</affiliation>
            <email href="mailto:john@saxonica.com">john@saxonica.com</email>
         </author>
         <author role="contrib">
            <name>Christian Grün</name>
            <affiliation>BaseX GmbH</affiliation>
            <email href="mailto:christian.gruen@gmail.com">christian.gruen@gmail.com</email>
         </author>
         <author role="contrib">
            <name>Matthias Brantner</name>
            <affiliation>28msec GmbH</affiliation>
            <email href="mailto:matthias.brantner@28msec.com">matthias.brantner@28msec.com</email>
         </author>
         <author role="contrib">
            <name>Florent Georges</name>
            <affiliation>H2O Consulting</affiliation>
         </author>
      </authlist>
      <copyright>
         <p>Copyright © 2013 John Lumley, Christian Grün, Matthias Brantner and Florent Georges,
            published by the <loc href="http://w3.org/community/expath/">EXPath Community Group</loc>
            under the <loc href="https://www.w3.org/community/about/agreements/cla/">W3C Community
               Contributor License Agreement (CLA)</loc>. A human-readable <loc href="http://www.w3.org/community/about/agreements/cla-deed/">summary</loc> is
            available.</p>
         <p>This specification was published by the <loc href="http://www.w3.org/community/expath/">EXPath Community Group</loc>. It is not a W3C Standard nor is it on the W3C
            Standards Track. Please note that under the <loc href="http://www.w3.org/community/about/agreements/cla/">W3C Community Contributor
               License Agreement (CLA)</loc> there is a limited opt-out and other conditions apply.
            Learn more about <loc href="http://www.w3.org/community/">W3C Community and Business
               Groups</loc>.</p>
      </copyright>
      <abstract>
         <p>This proposal provides an API for XPath 2.0 and XPath 3.0 to handle archive data (i.e.
            collected and possibly compressed sets of files and directories). It defines extension
            functions to process data from and to such archives files, including creation,
            determining and setting properties, listing and extracting contents and adding and
            updating entries. It has been designed to be compatible with XQuery 1.0 and XSLT 2.0, as
            well as any other XPath 2.0 usage. Some additional features for use in XPath 3.0 are
            also defined.</p>
      </abstract>
      <status>
         <p/>
      </status>
      <langusage>
         <language>en-US</language>
      </langusage>
      <revisiondesc>
         <p>revisiondesc</p>
      </revisiondesc>
   </header>
   <body>
      <div1 id="status">
         <head>Status of this document</head>
         <p>This document is in an interim draft stage. Comments are welcomed at <loc href="mailto:public-expath@w3.org">public-expath@w3.org</loc> mailing list (<loc href="http://lists.w3.org/Archives/Public/public-expath/">archive</loc>).</p>
      </div1>
      <div1 id="introduction">
         <head>Introduction</head>
         <div2>
            <head>Namespace Conventions</head>
            <p>The module defined by this document defines several functions, all contained in the
               namespace <code>http://expath.org/ns/archive</code>. In this document, the
                  <code>arch</code> prefix, when used, is bound to this namespace URI.</p>
            <p>Alternative versions of these functions using the proposed XPath3.0
                  <code>map()</code> type (see <specref ref="using.maps"/>) are defined in the
               namespace <code>http://expath.org/ns/archiveMap</code>. In this document, the
                  <code>archM</code> prefix, when used, is bound to this namespace URI. </p>
            <p>Error codes are defined in the same namespace
                  (<code>http://expath.org/ns/archive</code>), and in this document are displayed
               with the same prefix, <code>arch</code>.</p>
            <note>
               <p>This follows the suggestion (in late August 2013) for a coherent naming standard
                  in EXPath modules.</p>
            </note>
            <p>Binary file I/O, to read and write complete archives to files, uses facilities
               defined in the <loc href="http://expath.org/spec/file">EXPath File Module</loc>,
               which defines functions in the namespace <code>http://expath.org/ns/file</code>. In
               this document, the <code>file</code> prefix, when used, is bound to this namespace
               URI.</p>
            <p>Manipulation of binary data itself can employ functions from <loc href="http://expath.org/spec/binary">EXPath Binary Module</loc>, which defines
               functions in the namespace <code>http://expath.org/ns/binary</code>. In this
               document, the <code>bin</code> prefix, when used, is bound to this namespace URI.</p>
         </div2>
         <div2>
            <head>Error management</head>
            <p>Error conditions are identified by a code (a <code>QName</code>.) When such an error
               condition is reached in the evaluation of an expression, a dynamic error is thrown,
               with the corresponding error code (as if the standard XPath function
                  <code>error()</code> had been called.)</p>
         </div2>
         <div2 id="type">
            <head>Archive representation</head>
            <p>Archives in this module are represented principally as items of type
                  <code>xs:base64Binary</code>, i.e. in their basic binary (byte sequence)
               forms.</p>
            <p>Archives are treated as being arranged structurally as a description of overall
               options of the archive and a sequence of named entries. Each entry has:</p>
            <ulist>
               <item>
                  <p>A <emph>name</emph> of the entry, which is treated as a sequence of Unicode
                     characters. In many cases the solidus character (<code>/</code>) is used to
                     imply the entries being logically arranged in positions within a directory
                     tree, but this is not mandatory.</p>
               </item>
               <item>
                  <p>A set of <emph>properties</emph> of the entry, denoting at least the
                     uncompressed size of the entry, archive internal properties for the entry, such
                     as the compression method used on the stored data and other indications such as
                     the date of last modification.</p>
               </item>
               <item>
                  <p>The <emph>data</emph> for the entry, treated as (possibly null) binary
                     data.</p>
               </item>
            </ulist>
            <p>It is most common that archives are considered to be arranged logically as
               directories, using the entry names to denote paths and file names (e.g.
                  <code>tests/qt3/archive/main.xml</code>) In such circumstances, archives may
               contain entries to represent the directories themselves (e.g.
                  <code>tests/qt3/archive/</code>) presumably with no data. [This could be used such
               that full extraction of an archive to a file system generates empty output
               directories for example.] This specification makes no distinction between these two
               cases - if an archive has an empty 'directory' entry it will be treated similarly to
               any other 'file' entry. <emph>Semantic intrepretation of entry names as files in
                  directory trees is an application issue.</emph></p>
            <note>
               <p>Behaviour when entries with duplicate names are detected in an archive is
                  implementation dependent. Nevertheless, if an error is not thrown, only
                     <emph>one</emph> entry should be returned when reading. Implementations
                     <rfc2119>must not</rfc2119> write duplicate entries in result archives.</p>
            </note>
         </div2>
         <div2 id="archive.types">
            <head>Archive Types</head>
            <p>The module is designed to be able to support a number of different types of archive,
               providing a coherent access mechanism.</p>
            <p>The following archive types are required to be supported:</p>
            <ulist>
               <item>
                  <p><bibref ref="zip"/>: (which also covers derivative archive formats, such as JAR
                     or OpenDocument.)</p>
               </item>
               <item>
                  <p><bibref ref="gzip"/> : A compressed archive of a sequence of files</p>
                  <note>
                     <p>Within GZIP names of entries (original file names) are optional, on a
                        per-file basis, so special measures may need to be taken to handle 'unnamed'
                        sections.</p>
                  </note>
               </item>
            </ulist>
            <p>Specific issues arise from i) archives used in streaming situations, where the
               internal manifests of the archives cannot be completed until all data is written, ii)
               archives where the order of entries is important, such as JAR, where the mainfest
               entries need to be first.</p>
            <note>
               <p>Currently there are no proposals within this module to cover encrypted
                  archives.</p>
            </note>
         </div2>

      </div1>
      <div1 id="use-cases">
         <head>Use cases</head>
         <p>Development of this specification was driven by requirements which some XML developers
            regularly encounter in examining or generating data which is presented in archival
            forms. Some typical use cases include:</p>
         <ulist>
            <item>
               <p>Manipulating EPUB documents.</p>
            </item>
            <item>
               <p>Examining Java classes and resources stored in <code>JAR</code> formats.</p>
            </item>
         </ulist>
         <div2 id="example.epub">
            <head>Creating a simple EPUB document</head>
            <p>An <bibref ref="epub"/> document is a collection of content sections, written in
               XHTML, with a metadata descriptor (usually the <code>content.opf</code> file) and a
               navigation description (usually the <code>toc.ncx</code> file), all collected
               together and potentially compressed in a ZIP format. A simple example of creating
               such a document in XQuery is:</p>
            <eg xml:space="preserve">
arch:create(
    (
      { "name" : "mimetype", "compression" : "store" },
      "META-INF/container.xml",
      "OEBPS/content.opf",
      "OEBPS/Text/title.xhtml",
      "OEBPS/Text/chap01.xhtml",
      "OEBPS/toc.ncx"
    ),
    (
      content:mimetype(),
      content:metainf(),
      content:oebps-content(),
      content:title(),
      content:chapter(),
      content:toc()
    )
  )
</eg>
            <p>The user-supplied XQuery function <code>content:mimetype()</code> returns the
               appropriate mimetype description for the EPUB document as a string
               ("application/epub+zip"). Each of the other <code>content:*()</code> functions
               generates a serialized form of the appropriate XML structure, e.g.:</p>
            <eg xml:space="preserve">
declare function content:title() as xs:string
{
  fn:serialize(
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
    &lt;head&gt;
      &lt;title&gt;Title Page&lt;/title&gt;
    &lt;/head&gt;
    
    &lt;body&gt;
      &lt;div&gt;
        &lt;h2 id="heading_id_2"&gt;Sample Book&lt;/h2&gt;
    
        &lt;h2 id="heading_id_3"&gt;A Sample .epub Book&lt;/h2&gt;
    
        &lt;h3 id="heading_id_4"&gt;Title Page&lt;/h3&gt;
      &lt;/div&gt;
    &lt;/body&gt;
    &lt;/html&gt;
  )
};
</eg>
            <p>Using a map struture to define an entry enables properties such as compression to be
               altered on on entry-by-entry basis. For and EPUB document the mimetype entry
                  <emph>must</emph> be uncompressed (so effectively it can be read by simple string
               searching), but other entries may be compressed.</p>
         </div2>
         <div2 id="example.jar">
            <head>Examining a JAR file</head>
            <p>JAR files contain class code and definitions for Java classes, in entries whose names
               are <code><emph>path/classname</emph>.class</code>. Local classes (classes defined
               within a class) have separate code entries with a classname
                     <code><emph>outerclass</emph>$<emph>innerclass</emph></code>. To find all the
               main package-qualified classes the following XPath should suffice: </p>
            <eg xml:space="preserve">
for $e in arch:entries(file:read-binary("lib/saxon9-sql.jar"))[ends-with(.,'.class') and not(contains(.,'$'))] 
  return replace(replace($e,'\.class$',''),'/','.')
=&gt; 
   "net.sf.saxon.option.sql.SQLClose", 
   "net.sf.saxon.option.sql.SQLColumn", 
   "net.sf.saxon.option.sql.SQLConnect",
   ....,
   "net.sf.saxon.option.sql.SQLUpdate" 
</eg>
         </div2>
         <div2 id="example.zip">
            <head>Extracting a ZIP archive to a file system</head>
            <p>Assuming the ZIP file in question has (empty) entries denoting any directories
               required, the following XSLT will unzip an archive to the current directory, using
               the file writing functions of <bibref ref="expathfile"/>: </p>
            <eg xml:space="preserve">
&lt;xsl:variable name="arch" select="file:read-binary($uri)"/&gt;
&lt;xsl:variable name="entries" select="arch:entries($arch)"/&gt;
&lt;xsl:variable name="dirs" select="$entries[ends-with(.,'/')]"/&gt;
&lt;xsl:variable name="required.dirs"
            select="for $r in distinct-values(($entries except $dirs) return
            replace($r,'/[^/]+$','/'))[ends-with(.,'/')]"/&gt;
&lt;xsl:sequence select="for $d in distinct-values(($required.dirs,$dirs))
         return file:create-dir(replace($d,'/$',''))"/&gt;
&lt;xsl:sequence select="for $f in ($entries except $dirs) 
        return file:write-binary($f,arch:extract-binary($arch,$f))"/&gt;
</eg>
            <p>(<code>file:create-dir()</code> creates necessary intermediate directories, so
                  <code>$dirs</code> does not need to be in a sorted order. If the ZIP archive does
                  <emph>not</emph> have entries for all directories, further intermediate code is
               required to identify those missing.)</p>
         </div2>
      </div1>
      <div1 id="descriptions">
         <head>Describing archives and entries</head>
         <p>The properties of overall archives and individual entries at the XDM level are described
            by small structured elements, with optional information attached. <emph>In this proposal
               this information is attached as attributes.</emph></p>
         <note>
            <p>Parallels with XPath 3.0 serialization parameters, which are now sets of (element)
               nodes, become awkward. In <code>arch:entry</code> we would need to add an element
                  <code>arch:name</code> to hold the name of an entry, rather than rely on the
               string value. The major point in favour of using elements rather than attributes
               would be where we need to read or set complex structured parameters, such as
               character maps. This needs discussion.</p>
         </note>
         <div2 id="archive.properties">
            <head>Archive Properties and Options</head>
            <p>Archive options and properties are described as a structured element
                  (<code>element(arch:options)</code>) with the following attributes:</p>
            <ulist>
               <item>
                  <p><code>format</code>: the type of the archive, e.g. "zip". This is
                     mandatory.</p>
               </item>
               <item>
                  <p><code>algorithm</code>: the default compression used in the archive, e.g.
                     "deflate".</p>
               </item>
            </ulist>
            <p>Other attributes may be dependent upon the type of the archive and the
               implementation.</p>
         </div2>
         <div2 id="entry.structures">
            <head>Entry descriptions</head>
            <p>Entries within the archive can be accessed by name (<code>xs:string</code>) or a
               structured element (<code>element(arch:entry)</code>). In the latter case the entry
               name is the string value of the element.</p>
            <p>When describing an existing entry in an archive, <code>element(arch:entry)</code> may
               be returned with the following optional attributes:</p>
            <ulist>
               <item>
                  <p><code>size</code>: the original file size of the entry.</p>
               </item>
               <item>
                  <p><code>compressed-size</code>: the compressed file size of the entry, i.e. the
                     number of bytes it occupies in the archive.</p>
               </item>
               <item>
                  <p><code>last-modified</code>: the date of last modification of this entry, in
                        <code>xs:dateTime</code> notation.</p>
               </item>
               <item>
                  <p><code>compression-level</code>: an indicator of the level of (lossless?)
                     compression.</p>
               </item>
            </ulist>
            <p>When used to create or update an entry in an archive,
                  <code>element(arch:entry)</code> may also have the following optional
               attributes:</p>
            <ulist>
               <item>
                  <p><code>last-modified</code>: the date of last modification to be written on this
                     entry, in <code>xs:dateTime</code> notation.</p>
               </item>
               <item>
                  <p><code>compression-level</code>: the level of (lossless?) compression to be used
                     in writing the entry into the archive.</p>
               </item>
               <item>
                  <p><code>encoding</code>: the encoding to be used for converting textual items to
                     a byte sequence, prior to possible compression and writing to the archive.</p>
               </item>
            </ulist>
            <p>(In writing actions, unknown attributes are ignored.)</p>
         </div2>
         <div2 id="using.maps">
            <head>Using map types to describe entries and options</head>
            <p>Proposals in XPath 3.0 have been made for a type
                  <code>map(xs:untypedAtomic,item()*)</code>, which could be exploited beneficially
               for manipulating archives, using the entry name as the key and the
                  (<code>xs:base64Binary</code>) value of the entry as the corresponding value in
               the map. These maps could be used both as output (in <code>arch:entries()</code> and
                  <code>arch:extract-[text|binary]()</code>) or for input (in
                  <code>arch:update()</code> and <code>arch:create()</code>). Equally well such maps
               can be used, reading keys only in <code>arch:delete()</code>.</p>
            <p>An attractive alternative would be for each entry itself to be a <code>map($property
                  as xs:string, $value as item()*)</code>, with suitable keys, e.g.
                  <code>content</code> -&gt; <code>xs:base64Binary</code>. Thus the entry 'set' can be
               a map <code>map(xs;string, map(xs:string,item()*))</code>.</p>
            <note>
               <p>Functions using such maps for arguments and results could either have separate
                  names (e.g. <code>arch:entries-as-map()</code>) or be defined in a separate
                  namespace (<code>archM:entries()</code>) - in this current draft the second is
                  used. Details are discussed in <specref ref="maps"/></p>
            </note>

            <p>Support for similar approaches using other map representations, such as <bibref ref="jsoniq"/> objects may be implementation dependent.</p>
         </div2>
      </div1>
      <div1 id="loading">
         <head>Loading and saving archives</head>
         <p>This module defines no specific functions for reading and writing archives from files,
            as distinct from their binary data. The EXPath File Module <bibref ref="expathfile"/>
            provides two suitable functions to do this:</p>
         <ulist>
            <item>
               <p>
                  <ex:function><a href="http://expath.org/spec/file#d3e954">file:read-binary</a></ex:function>($file as <ex:type>xs:string</ex:type>) as
                     <ex:type>xs:base64Binary</ex:type>. Returns the content of a file in its Base64
                  representation.</p>
            </item>
            <item>
               <p>
                  <ex:function><a href="http://expath.org/spec/file#d3e1359">file:write-binary</a></ex:function>($file as <ex:type>xs:string</ex:type>,
                  $value as <ex:type>xs:base64Binary</ex:type>) as
                     <ex:type>empty-sequence()</ex:type>. Writes a Base64 item as binary to a file.
               </p>
            </item>
         </ulist>
         <note>
            <p>There may be some desire for some convenience functions <code>arch:write($file as
                     <ex:type>xs:string</ex:type>,....) as empty-sequence()</code> which does
               creation and file writing as one action.</p>
         </note>
      </div1>
      <div1 id="information">
         <head>Information about an archive and its contents</head>

         <div2 id="options">
            <head>arch:options</head><glist><gitem><label>Summary</label><def>
         <p>Returns a description of the type and properties of a given archive. </p>
      </def></gitem><gitem><label>Signature</label><def><p><example role="signature"><proto name="options" return-type="element(arch:options)*" isOp="no" prefix="arch">
            <arg name="archive" type="xs:base64Binary"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>The description is returned as an element <code>&lt;arch:options&gt;</code> with an
            unordered sequence of child elements describing the details. The following are currently
            supported:</p>
         <ul>
            <li><code>arch:format</code>: format of this archive</li>
            <li><code>arch:algorithm</code>: the compression algorithm that was used.</li>
         </ul>
         <p>If the archive format supports a compression algorithm varying on a per-entry basis, and
            more than one algorithm has been used in the archive, <code>mixed</code> is returned for
               <code>arch:algorithm</code>.</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.archiveReadError"/> is raised if there is an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Examples</label><def>
         
            <p>Finding the properties of the archive stored in a file located at
               <code>$uri</code>:</p>
            <eg xml:space="preserve">
arch:options(file:read-binary($uri))
=&gt; &lt;arch:options&gt;
     &lt;arch:format&gt;ZIP&lt;/arch:format&gt;
     &lt;arch:algorithm&gt;deflate&lt;/arch:algorithm&gt;
   &lt;/arch:options&gt;</eg>
         
      </def></gitem></glist>
         </div2>
         <div2 id="entries">
            <head>arch:entries</head><glist><gitem><label>Summary</label><def>
         <p>Returns the set of entry descriptors for all the entries found within the archive. </p>
      </def></gitem><gitem><label>Signature</label><def><p><example role="signature"><proto name="entries" return-type="element(arch:entry)*" isOp="no" prefix="arch">
            <arg name="archive" type="xs:base64Binary"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Each descriptor is an element <code>&lt;arch:entry&gt;</code> whose text value is the
            path of the file within the archive. For more details of this structure see <specref ref="entry.structures"/>.</p>
         <p>The entries are returned in the order in which they encountered serially within the
            archive.</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.archiveReadError"/> is raised if there is an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Notes</label><def>
         <p>There may be a case for providing a sorted version, probably using some form of
            collation.</p>
      </def></gitem><gitem><label>Examples</label><def>
         
            <p>Finding the entries of the archive stored in a file located at <code>$uri</code>:</p>
            <eg xml:space="preserve">
arch:entries(file:read-binary($uri))
=&gt; &lt;arch:entry size="2194" compressed-size="652" last-modified="2013-07-18T11:22:12"&gt;build.xml&lt;/arch:entry&gt;
   &lt;arch:entry size="84983" compressed-size="84872" last-modified="2009-03-23T11:15:06"&gt;lumley.jpg&lt;/arch:entry&gt;
   &lt;arch:entry size="10058" compressed-size="1381" last-modified="2013-08-06T13:14:08"&gt;tests/qt3/binary/binary.xml&lt;/arch:entry&gt;
     </eg>
            <p>Counting the number of apparent XML files in the previous example:</p>
            <eg xml:space="preserve">
count(arch:entries(file:read-binary($uri))[ends-with(.,'.xml')])
=&gt; 2
     </eg>
         
      </def></gitem></glist>
         </div2>
      </div1>
      <div1 id="extraction">
         <head>Extracting entries from an archive</head>
         <p>The module does not attempt to discern the 'type' of an entry (such as 'text', 'XML',
            'raw-binary'), leaving that to the programmer. Two forms of reading result are
            supported: raw binary (<code>xs:base64Binary</code>) and decoded text
               (<code>xs:string</code>). </p>
         <div2 id="extract.binary">
            <head>arch:extract-binary</head><glist><gitem><label>Summary</label><def>
         <p>Returns the sequence of requested entries from the archive as binary data.</p>
      </def></gitem><gitem><label>Signature</label><def><p><example role="signature"><proto name="extract-binary" return-type="xs:base64Binary*" isOp="no" prefix="arch">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="xs:string*"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns as binary data each entry in the archive <code>$in</code> that corresponds to
            the entry name input, in sequence.</p>
         <p>The entries <rfc2119>must</rfc2119> be returned in the order corresponding to that of
            the entries requested in <code>$entries</code>, not in the order in which they may exist
            in the archive.</p>
         <p>Multiple requests for the same entry will be honoured, with copies of the entry
            appearing in corresponding multiple locations in the output sequence .</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.unknownEntry"/> is raised if an entry requested does not exist in
            this archive.</p>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Notes</label><def>
         <p>There have been suggestions for a signature <code>arch:extract-binary($archive as
               xs:base64Binary)</code> returning all the entries. In the absence of maps in the
            return type, this does not make sense, since the entries are totally unlabelled, and to
            get anything meaningful, a parallel call on <code>arch:entries()</code> would be
            required.</p>
      </def></gitem><gitem><label>Examples</label><def>
         
            <p>Returning the binary data for an entry in the archive stored in a file located at
                  <code>$uri</code>:</p>
            <eg xml:space="preserve">
arch:extract-binary(file:read-binary($uri),'build.xml')
=&gt; stuff
     </eg>

         
      </def></gitem></glist>
         </div2>
         <div2 id="extract.text">
            <head>arch:extract-text</head><glist><gitem><label>Summary</label><def>
         <p>Returns the sequence of requested entries from the archive as strings. If
               <code>$encoding</code> is specified the strings are decoded appropriately, otherwise
            UTF-8 encoding is assumed.</p>
      </def></gitem><gitem><label>Signatures</label><def><p><example role="signature"><proto name="extract-text" return-type="xs:string*" isOp="no" prefix="arch">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="xs:string*"/>
         </proto></example><example role="signature"><proto name="extract-text" return-type="xs:string*" isOp="no" prefix="arch">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="xs:string*"/>
            <arg name="encoding" type="xs:string"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns as a string each entry in the archive <code>$in</code> that corresponds to the
            entry name input, in sequence.</p>
         <p>If <code>$encoding</code> is specified the strings are decoded appropriately, otherwise
            UTF-8 encoding is assumed.</p>
         <p>The entries <rfc2119>must</rfc2119> be returned in the order corresponding to that of
            the entries requested in <code>$entries</code>, not in the order in which they may exist
            in the archive.</p>
         <p>Multiple requests for the same entry will be honoured, with copies of the entry
            appearing in corresponding multiple locations in the output sequence .</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.unknownEntry"/> is raised if an entry requested does not exist in
            this archive.</p>
         <p><bibref ref="error.unknownEncoding"/> is raised if the encoding requested is unknown or
            unsupported.</p>
         <p><bibref ref="error.decoding"/> is raised if there was an error in decoding the
            entry.</p>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Notes</label><def>
         <p>This function should be equivalent to the use of <code>arch:extract-binary()</code> and
            the function <code>bin:decode-string()</code> from <bibref ref="expathbinary"/>:</p>
         <eg>arch:extract-binary($in,$entries) ! bin:decode-string(.,$encoding) [XPath 3.0]</eg>
         <eg>for $b in arch:extract-binary($in,$entries) return bin:decode-string($b,$encoding)
            [XPath 2.0]</eg>
         <p>Further conversion into XML can be achieved using the XPath3.0 function
               <code>fn:parse-XML()</code> on each of the returned strings.</p>
         <p>There have been suggestions for a signature <code>arch:extract-text($archive as
               xs:base64Binary)</code> returning all the entries. In the absence of maps in the
            return type, this does not make sense, since the entries are totally unlabelled, and to
            get anything meaningful, a parallel call on <code>arch:entries()</code> would be
            required.</p>
      </def></gitem><gitem><label>Examples</label><def>
         
            <p>Returning the text data for an entry in the archive stored in a file located at
                  <code>$uri</code>:</p>
            <eg xml:space="preserve">
arch:extract-text(file:read-binary($uri),'build.xml','UTF-8')
=&gt; stuff
     </eg>
         
      </def></gitem></glist>
         </div2>
      </div1>
      <div1 id="updating">
         <head>Updating entries in an archive</head>
         <p>There are two atomic actions available to change entries within an archive: complete
            deletion of an entry, or complete updating (overwriting) of that entry - the latter adds
            new entries when the given name does not already exist in the archive</p>
         <div2 id="delete">
            <head>arch:delete</head><glist><gitem><label>Summary</label><def>
         <p>Returns an archive with the given entries deleted.</p>
      </def></gitem><gitem><label>Signature</label><def><p><example role="signature"><proto name="delete" return-type="xs:base64Binary" isOp="no" prefix="arch">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="xs:string*"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns an archive of the same format as <code>$in</code> with all the entries named in
               <code>$entries</code> deleted.</p>
         <p>The relative order of the remaining entries within the archive is preserved.</p>
         <p>The uncompressed content, size and last-modified date of the remaining entries shall be
            the same as those for those entries before deletion. Compressed sizes may alter.</p>
         <p>Duplicate entries in <code>$entries</code> are ignored.</p>
         <p>If <code>$entries</code> is the empty sequence, the original archive shall be
            returned.</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.unknownEntry"/> is raised if an entry requested for deletion does not
            exist in this archive.</p>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Notes</label><def>
         <p>Whilst the uncompressed entries remaining after deletion should of course be the same
            size and content as those before deletion, depending upon the (lossless) compression
            algorithm used, the compressed sizes and content might not be. In the absence of a
            special check, in these circumstances <code>$in</code> may not be identical to
               <code>arch:delete($in,())</code>. This needs discussion. </p>
      </def></gitem><gitem><label>Examples</label><def>
         
            <p>Deleting the entries of the archive stored in a file located at
               <code>$uri</code>:</p>
            <eg xml:space="preserve">
arch:entries(arch:delete(file:read-binary($uri),'lumley.jpg'))
=&gt; &lt;arch:entry size="2194" compressed-size="652" last-modified="2013-07-18T11:22:12"&gt;build.xml&lt;/arch:entry&gt;
   &lt;arch:entry size="10058" compressed-size="1381" last-modified="2013-08-06T13:14:08"&gt;tests/qt3/binary/binary.xml&lt;/arch:entry&gt;
     </eg>
         
      </def></gitem></glist>
         </div2>
         <div2 id="update">
            <head>arch:update</head><glist><gitem><label>Summary</label><def>
         <p>Returns an archive with each of the given entries in <code>$entries</code> updated to
            the corresponding values in the sequence <code>$new</code>. If an entry is not found, a
            new entry is added to the end of the archive.</p>
      </def></gitem><gitem><label>Signatures</label><def><p><example role="signature"><proto name="update" return-type="xs:base64Binary" isOp="no" prefix="arch">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="xs:string*"/>
            <arg name="new" type="xs:base64Binary*"/>
         </proto></example><example role="signature"><proto name="update" return-type="xs:base64Binary" isOp="no" prefix="arch">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="xs:string*"/>
            <arg name="new" type="xs:base64Binary*"/>
            <arg name="last-modified" type="xs:dateTime"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns an archive of the same format as <code>$in</code> with each of the given entries
            in <code>$entries</code> updated to the corresponding value in the sequence
               <code>$new</code>. If an entry is not found, a new entry for it is added to the end
            of the archive.</p>
         <p>The relative order of all the existing and replaced entries within the archive is
            preserved. New entries appear at the end of the archive in the order in which they were
            specified in the call.</p>
         <p>If specified, and the format supports it, the last-modified date for each of the updated
            entries will be set to <code>$last-modified</code>. In the absence of such a parameter,
            it is implementation-dependent whether last-modified information will be written on the
            updated entries. If such default last-modification is written, it should be comparable
            to the value of <code>fn:current-dateTime()</code> in an XSLT environment.</p>
         <p>The uncompressed content, size and last-modified date of the remaining entries shall be
            the same as those for those entries before deletion. Compressed sizes may alter.</p>
         <p>The compression methods of the updated entries shall be preserved.</p>
         <p>When duplicate names appear in the entry list, the value of the entry in the resulting
            archive will be that of the value of <code>$new</code> corresponding to the
               <emph>last</emph> matching entry name. </p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.entryDataMismatch"/> is raised if <code>count($entries) ne
               count($new)</code>.</p>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            reading or creating the archive.</p>
      </def></gitem></glist>
         </div2>
      </div1>
      <div1 id="creating">
         <head>Creating an archive</head>
         <p>new archives need to be created </p>
         <div2 id="create">
            <head>arch:create</head><glist><gitem><label>Summary</label><def>
         <p>Returns a new archive with each of the given entries in <code>$entries</code> set to the
            corresponding values in the sequence <code>$new</code>.</p>
      </def></gitem><gitem><label>Signatures</label><def><p><example role="signature"><proto name="create" return-type="xs:base64Binary" isOp="no" prefix="arch">
            <arg name="entries" type="xs:string*"/>
            <arg name="new" type="xs:base64Binary*"/>
         </proto></example><example role="signature"><proto name="create" return-type="xs:base64Binary" isOp="no" prefix="arch">
            <arg name="entries" type="xs:string*"/>
            <arg name="new" type="xs:base64Binary*"/>
            <arg name="options" type="element(arch:options)"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns an archive of format specified by <code>$options</code> with each of the given
            entries in <code>$entries</code> set to the corresponding value in the sequence
               <code>$new</code>.</p>
         <p>The relative order of new entries within the archive follows that of the input.</p>
         <p>When duplicate names appear in the entry list, the value of the entry in the resulting
            archive will be that of the value of <code>$new</code> corresponding to the
               <emph>last</emph> matching entry name. </p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.entryDataMismatch"/> is raised if <code>count($entries) ne
               count($new)</code>.</p>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            reading or creating the archive.</p>
      </def></gitem></glist>
         </div2>
      </div1>
      <div1 id="maps">
         <head>Functions using XPath3.0 map() type</head>
         <p>Maps proposed for XPath3.0 can increase the coherence of the functions in the module,
            mainly by retaining the structured connection between the entry name and its properties
            and content. In addition the properties of the overall archive (and its defaults for new
            entries) can similarly be defined in a single map.</p>
         <p>This section proposes parallel functions to those above using maps.</p>
         <note>
            <p><code>map:keys($map as map(*)) as xs:anyAtomicType*</code> returns the keys that are
               present in a map, in unpredictable order. This means that if order within an archive
               is important (either in extraction or updating) other mechanisms may be needed.</p>
            <p>In general when using maps for denoting the entries to be manipulated, the arguments
               might be considered to be a (possibly empty) sequence of maps that are treated as if
               concatentated. [THIS NEEDS THOUGHT ABOUT OVERWRITING/MERGING COMMON KEYS]</p>
         </note>
         <div2 id="archive.options.map">
            <head>Archive property maps</head>
            <p>Using a reserved name within the overall map (such as <code>arch:options</code>)
               would allow the options/properties for an archive to be stored alongside the
               entries.</p>
         </div2>
         <div2 id="entry.structures.map">
            <head>Entry property maps</head>
            <p>Entries within the archive can be also be accessed or described by entries in a map
                  (<code>map(xs:string,map(xs:string,item()*))</code>). In this case the map key
               gives the (path)name of the archive entry (e.g. <code>build/build-j.xml</code>) and
               the value is a map of the properties of that entry.</p>
            <p>The following keys are provided when reporting on entries:</p>
            <ulist>
               <item>
                  <p><code>size</code>: the original file size of the entry as
                        <code>xs:integer</code></p>
               </item>
               <item>
                  <p><code>compressed-size</code>: the compressed file size of the entry as
                        <code>xs:integer</code>, i.e. the number of bytes it occupies in the
                     archive.</p>
               </item>
               <item>
                  <p><code>last-modified</code>: the date of last modification of this entry, in
                        <code>xs:dateTime</code> notation</p>
               </item>
               <item>
                  <p><code>compression-level</code>: an indicator of the level of (lossless?)
                     compression.</p>
               </item>
               <item>
                  <p><code>content</code>: the value of the entry read from the archive, as
                        <code>xs:base64Binary</code>. This will only be set if
                        <code>$return-content</code> is requested in the call to
                        <code>archM:entries()</code>.</p>
               </item>
            </ulist>
            <p>When used to extract an entry from an archive, this map may have the following
               optional key/value pairs:</p>
            <ulist>
               <item>
                  <p><code>encoding</code>: the encoding to be used for converting textual items
                     from a byte sequence.</p>
               </item>
            </ulist>
            <p>When used to create or update an entry in an archive, this map may have the following
               optional key/value pairs:</p>
            <ulist>
               <item>
                  <p><code>content</code>: the value of the entry to be written in the archive,
                     either as <code>xs:base64Binary</code> or, when <code>encoding</code> is set,
                     as <code>xs:string</code>.</p>
                  <note>
                     <p><emph>This is awkward - why not just insist on <code>xs:base64Binary</code>
                           and let the programmer encode?</emph></p>
                  </note>
               </item>
               <item>
                  <p><code>last-modified</code>: the date of last modification to be written on this
                     entry, in <code>xs:dateTime</code> notation</p>
               </item>
               <item>
                  <p><code>compression-level</code>: the level of (lossless?) compression to be used
                     in writing the entry into the archive.</p>
               </item>
               <item>
                  <p><code>encoding</code>: the encoding to be used for converting textual items to
                     a byte sequence, prior to possible compression and writing to the archive.</p>
               </item>
            </ulist>
         </div2>
         <div2 id="options.map">
            <head>archM:options</head><glist><gitem><label>Summary</label><def>
         <p>Returns a description of the type and properties of a given archive as a map. </p>
      </def></gitem><gitem><label>Signature</label><def><p><example role="signature"><proto name="options" return-type="map(xs:string,item()?)" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>The description is returned as a map <code>map(xs:string,item()?)</code> with entries
            describing the details. The following are currently supported:</p>
         <ul>
            <li><code>format</code>: format of this archive</li>
            <li><code>compression</code>: the compression algorithm that was used.</li>
         </ul>
         <p>If the archive format supports a compression algorithm varying on a per-entry basis, and
            more than one algorithm has been used in the archive, <code>mixed</code> is returned for
            the <code>compression</code> entry.</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.archiveReadError"/> is raised if there is an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Examples</label><def>
         
            <p>Finding the properties of the archive stored in a file located at
               <code>$uri</code>:</p>
            <eg xml:space="preserve">
archM:options(file:read-binary($uri))
=&gt; {'format' :'zip', 'compression' : 'deflate'}
</eg>
         
      </def></gitem></glist>
         </div2>
         <div2 id="entries.map">
            <head>archM:entries</head><glist><gitem><label>Summary</label><def>
         <p>Returns the entry descriptors for all the entries found within the archive as a map,
            optionally each with their content.</p>
      </def></gitem><gitem><label>Signatures</label><def><p><example role="signature"><proto name="entries" return-type="map(xs:string,map(xs:string,item()*))" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
         </proto></example><example role="signature"><proto name="entries" return-type="map(xs:string,map(xs:string,item()*))" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="return-content" type="xs:boolean"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Keys to the returned map are the entry (path) names.</p>
         <p>The value for each map entry is a map describing the properties of that entry. For more
            details of this structure see <specref ref="entry.structures.map"/>.</p>
         <p>If <code>$return-content</code> is defined and equals <code>true()</code>, then the
            content for each entry is returned as the <code>content</code> entry in the property
            map, as a <code>xs:base64Binary</code> item.</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.archiveReadError"/> is raised if there is an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Notes</label><def>
         <p>As the returned order of keys from <code>map:keys()</code> is not defined and can be
            implementation-dependant, there may be a need for a simple function
               (<code>archM:entry-names(xs:base64Binary) as xs:string*)</code> which returns purely
            the names <em>in the order in which they appear in the archive.</em></p>
         <p>Using <code>$return-content</code> makes it possible to return a complete archive in a
            single call. <em>(What about the archive options?</em></p>
      </def></gitem><gitem><label>Examples</label><def>
         
            <p>Finding the entries of the archive stored in a file located at <code>$uri</code>:</p>
            <eg xml:space="preserve">
archM:entries(file:read-binary($uri))
=&gt; map{ 
  "build.xml" := map{ "size":=2194, "compressed-size":=652, "last-modified":="2013-07-18T11:22:12"},
  "lumley.jpg" := map{ "size":=84983, "compressed-size":=84872, "last-modified":="2009-03-23T11:15:06"},
  "tests/qt3/binary/binary.xml" := map{ "size":=10058, "compressed-size":=1381, "last-modified":="2013-08-06T13:14:08"}}
     </eg>
            <p>Counting the number of apparent XML files in the previous example:</p>
            <eg xml:space="preserve">
count(map:keys(archM:entries(file:read-binary($uri)))[ends-with(.,'.xml')])
=&gt; 2
     </eg>
         
      </def></gitem></glist>
         </div2>
         <div2 id="entry.names.map">
            <head>archM:entry-names</head><glist><gitem><label>Summary</label><def>
         <p>Returns the entry names for all the entries found within the archive as a sequence of
            string values in the order in which they appear in the archive.</p>
      </def></gitem><gitem><label>Signature</label><def><p><example role="signature"><proto name="entry-names" return-type="xs:string*" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns the entry names for all the entries found within the archive as a sequence of
            string values in the order in which they appear in the archive.</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.archiveReadError"/> is raised if there is an unspecified problem in
            reading the archive.</p>
      </def></gitem></glist>
         </div2>
         <div2 id="extractmap">
            <head>archM:extract</head><glist><gitem><label>Summary</label><def>
         <p>Returns a copy of <code>$entries</code> with the content entries set to binary or
            decoded string data for the appropriate entry in the archive.</p>
      </def></gitem><gitem><label>Signature</label><def><p><example role="signature"><proto name="extract" return-type="map(xs:string,map(xs:string,item()?))" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="map(xs:string,map(xs:string,item()?))"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>The map entries in <code>$entries</code> define whether binary or decoded string data is
            to be returned.</p>
         <p>The behaviour of this function is defined by equivalent XPath:</p>
         <eg>
map:new(for $k in map:keys($entries) 
   return 
     let $a := $entries($k),
         $text := map:contains($a,'encoding'),
         $encoding := ($a('encoding'),'UTF-8')[1],
         $data := arch:extract-binary($archive,$k) // error if not found
     return 
         map:entry($k,
             map:new(($a,
               map:entry('content',if($text) bin:decode-string($data,$encoding) else $data)
               ))
       )
     </eg>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.unknownEntry"/> is raised if an entry requested does not exist in
            this archive.</p>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Examples</label><def>
         
            <p>To collect all the XML entries as XML:</p>
            <eg>
let $archive := file:read-binary($uri)
    $entries := archM:entries($archive),
    $xml-names := map:keys($entries)[ends-with(.,'.xml')],
    $get := map:new($xml-names ! map:entry(.,map:entry('encoding','UTF-8'))),
    $content := archM:extract($archive,$get)
return
    $xml-names ! fn:parse-XML($content(.)('content'))
     </eg>
         
      </def></gitem></glist>
         </div2>
         <div2 id="extract.binary.map">
            <head>archM:extract-binary</head><glist><gitem><label>Summary</label><def>
         <p>Returns the sequence of requested entries from the archive as binary data.</p>
      </def></gitem><gitem><label>Signatures</label><def><p><example role="signature"><proto name="extract-binary" return-type="xs:base64Binary*" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="map(xs:string,map(xs:string,item()?))"/>
         </proto></example><example role="signature"><proto name="extract-binary" return-type="xs:base64Binary*" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="xs:string*"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns as binary data each entry in the archive <code>$in</code> that corresponds to
            the entry name input, or <code>map:keys($entries)</code>, in sequence.</p>
         <p>When <code>$entries</code> has type <code>xs:string*</code>, the entries
               <rfc2119>must</rfc2119> be returned in the order corresponding to that of the entries
            requested in <code>$entries</code>, not in the order in which they may exist in the
            archive.</p>
         <p>When <code>$entries</code> has type <code>xs:string*</code>, multiple requests for the
            same entry will be honoured, with copies of the entry appearing in corresponding
            multiple locations in the output sequence .</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.unknownEntry"/> is raised if an entry requested does not exist in
            this archive.</p>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Notes</label><def>
         <p>Collection of all the entries as binary data can be accomplished using
               <code>archM:entries($archive,true())</code> and collecting the <code>'content'</code>
            entry from each of the returned maps.</p>
         <p>The signatures with <code>$entries instance of xs:string*</code> are equivalent to
               <code>arch:extract-binary()</code>.</p>
      </def></gitem></glist>
         </div2>
         <div2 id="extract.text.map">
            <head>archM:extract-text</head><glist><gitem><label>Summary</label><def>
         <p>Returns the sequence of requested entries from the archive as decoded string data.</p>
      </def></gitem><gitem><label>Signatures</label><def><p><example role="signature"><proto name="extract-text" return-type="xs:string*" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="map(xs:string,map(xs:string,item()?))"/>
         </proto></example><example role="signature"><proto name="extract-text" return-type="xs:string*" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="map(xs:string,map(xs:string,item()?))"/>
            <arg name="encoding" type="xs:string"/>
         </proto></example><example role="signature"><proto name="extract-text" return-type="xs:string*" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="xs:string*"/>
         </proto></example><example role="signature"><proto name="extract-text" return-type="xs:string*" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="xs:string*"/>
            <arg name="encoding" type="xs:string"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns as decoded string data each entry in the archive <code>$in</code> that
            corresponds to the entry name input, or <code>map:keys($entries)</code>, in
            sequence.</p>
         <p>When <code>$entries</code> has type <code>xs:string*</code>, the entries
               <rfc2119>must</rfc2119> be returned in the order corresponding to that of the entries
            requested in <code>$entries</code>, not in the order in which they may exist in the
            archive.</p>
         <p>When <code>$entries</code> has type <code>xs:string*</code>, multiple requests for the
            same entry will be honoured, with copies of the entry appearing in corresponding
            multiple locations in the output sequence.</p>
         <p>If <code>$encoding</code> is specified, or the field <code>'decoding'</code> appears in
            the entry in <code>$entries</code>, the strings are decoded according to that encoding,
            otherwise UTF-8 encoding is assumed.</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.unknownEntry"/> is raised if an entry requested does not exist in
            this archive.</p>
         <p><bibref ref="error.unknownEncoding"/> is raised if an encoding requested is unknown or
            unsupported.</p>
         <p><bibref ref="error.decoding"/> is raised if there was an error in decoding an entry.</p>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Notes</label><def>
         <p>The signatures with <code>$entries instance of xs:string*</code> are equivalent to
               <code>arch:extract-text()</code>.</p>
      </def></gitem></glist>
         </div2>
         <div2 id="create.map">
            <head>archM:create</head><glist><gitem><label>Summary</label><def>
         <p>Returns a new archive with each of the given entries named as a key in
               <code>$entries</code> set to the corresponding value in
               <code>$entries($key)('content')</code>.</p>
      </def></gitem><gitem><label>Signatures</label><def><p><example role="signature"><proto name="create" return-type="xs:base64Binary" isOp="no" prefix="archM">
            <arg name="entries" type="map(xs:string,map(xs:string,item()?))*"/>
         </proto></example><example role="signature"><proto name="create" return-type="xs:base64Binary" isOp="no" prefix="archM">
            <arg name="entries" type="map(xs:string,map(xs:string,item()?))*"/>
            <arg name="options" type="map(xs:string,item())"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns an archive of format specified by <code>$options</code> with each of the given
            entries named as a key in <code>$entries</code> set to the corresponding value in
               <code>$entries($key)('content')</code>..</p>
         <p>The relative order of new entries within the archive follows that of the input.</p>
         <p>If <code>$options</code> is specified, the overall archive properties (and defaults for
            the entries) are set to those specified in the map.</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            creating the archive.</p>
      </def></gitem></glist>
         </div2>
         <div2 id="update.map">
            <head>archM:update</head><glist><gitem><label>Summary</label><def>
         <p>Returns an archive with each of the given entries in the keys of <code>$entries</code>
            updated to the corresponding values in the <code>$entries($key)('content')</code> and
            with other properties defined by <code>$entries($key)(*)</code>. If an entry is not
            found, a new entry is added to the end of the archive.</p>
      </def></gitem><gitem><label>Signatures</label><def><p><example role="signature"><proto name="update" return-type="xs:base64Binary" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="map(xs:string,map(xs:string,item()?))"/>
         </proto></example><example role="signature"><proto name="update" return-type="xs:base64Binary" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="map(xs:string,map(xs:string,item()?))"/>
            <arg name="default" type="map(xs:string,item())"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns an archive with each of the given entries in the keys of <code>$entries</code>
            updated to the corresponding values in the <code>$entries($key)('content')</code> and
            with other properties defined by <code>$entries($key)(*)</code>. If an entry is not
            found, a new entry is added to the end of the archive.</p>
         <p>If <code>$options</code> is specified, values will be used for the default properties
            for each entry, which may be overloaded by the property map for each individual
            entry.</p>
         <p>The relative order of all the existing and replaced entries within the archive is
            preserved. New entries appear at the end of the archive in the order in which they were
            specified in the call.</p>
         <p>The uncompressed content, size and last-modified date of the remaining entries shall be
            the same as those for those entries before deletion. Compressed sizes may alter.</p>
         <p>The compression methods of the updated entries shall be preserved.</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            reading or creating the archive.</p>
      </def></gitem><gitem><label>Notes</label><def>
         <p>Using the <code>$default</code> map a common compression method, last-modification date
            and similar can be set for a set of entries, whose minimal map entries are
               <code>map{"content":=$content}</code>
         </p>
      </def></gitem></glist>
         </div2>
         <div2 id="delete.map">
            <head>archM:delete</head><glist><gitem><label>Summary</label><def>
         <p>Returns an archive with the given entries deleted.</p>
      </def></gitem><gitem><label>Signatures</label><def><p><example role="signature"><proto name="delete" return-type="xs:base64Binary" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="xs:string*"/>
         </proto></example><example role="signature"><proto name="delete" return-type="xs:base64Binary" isOp="no" prefix="archM">
            <arg name="archive" type="xs:base64Binary"/>
            <arg name="entries" type="map(xs:string,map(xs:string,item()))*"/>
         </proto></example></p></def></gitem><gitem><label>Rules</label><def>
         <p>Returns an archive of the same format as <code>$in</code> with all the entries named in
               <code>$entries</code> or <code>$entries!map:keys(.)</code> deleted.</p>
         <p>The relative order of the remaining entries within the archive is preserved.</p>
         <p>The uncompressed content, size and last-modified date of the remaining entries shall be
            the same as those for those entries before deletion. Compressed sizes may alter.</p>
         <p>Duplicate entries in <code>$entries</code> are ignored.</p>
         <p>If <code>$entries</code> is the empty sequence, or an empty map, the original archive
            shall be returned.</p>
      </def></gitem><gitem><label>Error Conditions</label><def>
         <p><bibref ref="error.unknownEntry"/> is raised if an entry requested for deletion does not
            exist in this archive.</p>
         <p><bibref ref="error.archiveReadError"/> is raised if there was an unspecified problem in
            reading the archive.</p>
      </def></gitem><gitem><label>Notes</label><def>
         <p>Whilst the uncompressed entries remaining after deletion should of course be the same
            size and content as those before deletion, depending upon the (lossless) compression
            algorithm used, the compressed sizes and content might not be. In the absence of a
            special check, in these circumstances <code>$in</code> may not be identical to
               <code>arch:delete($in,())</code>. This needs discussion. </p>
         <p>The signature with <code>$entries as xs:string*</code> is defined as a convenience, to
            avoid the creation of a simple map. Otherwise it is completely analagous to
               <code>arch:delete(xs:base64Binary,xs:string*)</code>.</p>
      </def></gitem></glist>
         </div2>
      </div1>


   </body>

   <back>
      <div1 id="references">
         <head>References</head>
         <blist>

            <bibl id="epub" key="EPUB">
               <loc href="http://www.idpf.org/epub/30/spec/epub30-overview.html">EPUB 3
                  Overview</loc>. International Digital Publishing Forum. Recommended Specification
               11 October 2011.</bibl>
            <bibl id="expathfile" key="EXPathFile">
               <loc href="http://expath.org/spec/file">File Module</loc>. Christian Grün and
               Matthias Brantner, editors. EXPath Candidate Module. 14 June 2012.</bibl>
            <bibl id="expathbinary" key="EXPathBinary">
               <loc href="http://expath.org/spec/binary">Binary Module</loc>. Jirka Kosek and John
               Lumley, editors. EXPath Candidate Module. 6 August 2013.</bibl>
            <bibl id="fo30" key="F&amp;O 3.0">
               <loc href="http://www.w3.org/TR/xpath-functions-30/">XPath and XQuery Functions and
                  Operators 3.0</loc>. Michael Kay, editor. W3C Candidate Recommendation 21 May
               2013.</bibl>
            <bibl id="gzip" key="GZIP">
               <loc href="http://www.gzip.org/zlib/rfc-gzip.html">GZIP file format specification
                  version 4.3</loc>. L. Peter Deutsch, 1996.</bibl>
            <bibl id="jsoniq" key="JSONiq">
               <loc href="http://www.jsoniq.org/">JSONiq - The JSON Query Language</loc>. FLWOR
               Foundation. 2013.</bibl>
            <bibl id="xmlschema1.1" key="XML Schema 1.1 Part 2">
               <loc href="http://www.w3.org/TR/xmlschema11-2/">W3C XML Schema Definition Language
                  (XSD) 1.1 Part 2: Datatypes</loc>. David Peterson et al, editors.W3C
               Recommendation 5 April 2012.</bibl>
            <bibl id="zip" key="ZIP">
               <loc href="http://www.pkware.com/documents/casestudies/APPNOTE.TXT">ZIP File Format
                  Specification</loc>.PKWare, Version 6.3.3, 1 September 2012.</bibl>
         </blist>
      </div1>
      <div1 id="errors">
         <head>Summary of Error Conditions</head>
         <blist>
            <bibl id="error.archiveReadError" key="arch:read-error">There was an general error in
               reading the archive</bibl>
            <bibl id="error.unknownEntry" key="arch:unknown-entry">The specified entry does not
               exist in this archive.</bibl>
            <bibl id="error.entryDataMismatch" key="arch:entry-data-mismatch">The sequence of entry
               names is not the same length as the sequence of updated values.</bibl>
            <bibl id="error.unknownEncoding" key="arch:unknown-encoding">The specified encoding is
               not supported.</bibl>
            <bibl id="error.decoding" key="arch:decoding-error">Error in decoding a string.</bibl>


         </blist>
      </div1>
   </back>
</spec>