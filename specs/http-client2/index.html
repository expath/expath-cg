<!DOCTYPE html>
<html>
  <head>
    <title>HTTP Client Module 2.0</title>
    <meta charset='utf-8'/>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus: "base",

          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName: "http-client2",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          subtitle: "An EXPath Project",

          // if you wish the publication date to be other than today, set this
          // publishDate: "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate: "1977-03-15",
          // previousMaturity: "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI: "http://dev.w3.org/2009/dap/ReSpec.js/documentation.html",
          edDraftURI: "http://expath.github.io/expath-cg/specs/http-client2/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors: [
              { name: "Christian Grün", url: "http://christian-gruen.de/",
                company: "BaseX GmbH", companyURL: "http://basex.org/" },
              { name: "Adam Retter", url: "http://adamretter.org.uk/",
                company: "Evolved Binary", companyURL: "http://adamretter.org.uk/" }
          ],

          // authors, add as many as you like.
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.
          //authors: [
          //],

          // name of the WG
          wg: "EXPath Community Group",

          // URI of the public WG page
          wgURI: "https://www.w3.org/community/expath/",

          // name (without the @w3c.org) of the public mailing to which comments are due
          //wgPublicList: "exquery-restxq",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI: "",

          // If specified, defines an array of alternate formats in which document is available
          // (e.g., XML, Postscript). The format of the array is:
          // alternateFormats:

          doRDFa: "1.1",
      };
    </script>
  </head>
  <body>
    <!--<section id="sotd"/>
    </section>-->

    <section id='abstract'>
      <p>
        This specification provides an HTTP client interface for XML languages.
        It defines several extension functions to perform HTTP requests.
        It is backward-compliant with version 1.0 of the
        <a href='http://expath.org/spec/http-client'>HTTP Client Module</a>
        and has been designed to be compatible with [[!XQUERY-31]] and [[!XPATH-31]].
      </p>
    </section>

    <section id='introduction'>
      <h2>Introduction</h2>
      <p>
        The <a href='http://expath.org/spec/http-client'>HTTP Client Module</a> provides an HTTP
        client interface for XML languages. Version 2.0 provides the following features:
      </p>
      <ul>
        <li> Convenience functions are provided to make basic user requests more convenient.</li>
        <li> Maps and arrays were added to [[!XPATH-31]]. The functions take advantage of the new
          data structures.</li>
        <li> In the initial specification, different ways exist to supply some of the arguments,
          such as the request URI or the payload. In the new functions, single locations are
          defined for all arguments.</li>
        <li> Single and multipart bodies are always passed on as items and never passed on as text
          nodes of an XML body element. This simplifies lazy evaluation and streaming of data
          in implementations.
        </li>
      </ul>

      <section>
        <h2>Namespaces and Prefixes</h2>
        <p>
          All functions and errors in this module are assigned to the
          <code>http://expath.org/ns/http-client</code> namespace. In this document, the
          <code>http</code> prefix is bound to this URI.
        </p>
      </section>
    </section>

    <section id='functions'>
      <h2>Functions</h2>
      <p>
        The functions of this document have several things in common:
      </p>
      <ul>
        <li> All of them have been designed to send HTTP requests to a server, and
          to return the reponse to the client.</li>
        <li> The first parameter, <code>$uri</code>, contains the URI of the addressed
          server.</li>
        <li> The <code>$body</code> parameter is explained in
          <a href="#request-body" class="sectionRef"></a>.</li>
        <li> In <a href="#request-options" class="sectionRef"></a>, the supported
          <code>$options</code> are listed.</li>
        <li> In <a href="#response" class="sectionRef"></a>, the format of the returned result is
          described. It is identical for all functions (except for
          <a href="#http-options">http:options</a>, which returns a simple string sequnece).</li>
      </ul>
      <p>
        The legacy function <code>http:send-request</code> is still available; it is explained in
        detail in the original <a href='http://expath.org/spec/http-client'>HTTP Client Module</a>.
      </p>

      <section>
        <h3>http:get</h3>
        <div class="exampleInner">
          <pre>
http:get($uri as xs:string) as map(*)
http:get($uri as xs:string, $options as map(*)) as map(*)
</pre>
        </div>
        <p>
          Sends a GET request to the supplied <code>$uri</code> and returns the response as a map.
          Additional <code>$options</code> can be supplied.
        </p>
      </section>

      <section>
        <h3>http:post</h3>
        <div class="exampleInner">
          <pre>
http:post($uri as xs:string, $body as item()?) as map(*)
http:post($uri as xs:string, $body as item()?, $options as map(*)) as map(*)
</pre>
        </div>
        <p>
          Sends a POST request with an optional <code>$body</code> to the supplied
          <code>$uri</code> and returns the response as a map. Additional <code>$options</code> can
          be supplied.
        </p>
      </section>

      <section>
        <h3>http:put</h3>
        <div class="exampleInner">
          <pre>
http:put($uri as xs:string, $body as item()?) as map(*)
http:put($uri as xs:string, $body as item()?, $options as map(*)) as map(*)
</pre>
        </div>
        <p>
          Sends a PUT request with an optional <code>$body</code> to the supplied <code>$uri</code>
          and returns the response as a map. Additional <code>$options</code> can be supplied.
        </p>
      </section>

      <section>
        <h3>http:delete</h3>
        <div class="exampleInner">
          <pre>
http:delete($uri as xs:string) as map(*)
http:delete($uri as xs:string, $options as map(*)) as map(*)
</pre>
        </div>
        <p>
          Sends a DELETE request to the supplied <code>$uri</code> and returns the response as a
          map. Additional <code>$options</code> can be supplied.
        </p>
      </section>

      <section>
        <h3>http:head</h3>
        <div class="exampleInner">
          <pre>
http:head($uri as xs:string) as map(*)
http:head($uri as xs:string, $options as map(*)) as map(*)
</pre>
        </div>
        <p>
          Sends a HEAD request to the supplied <code>$uri</code> and returns the response as a map.
          Additional <code>$options</code> can be supplied.
        </p>
      </section>

      <section>
        <h3>http:options</h3>
        <div class="exampleInner">
          <pre>
http:options($uri as xs:string) as xs:string*
http:options($uri as xs:string, $options as map(*)) as xs:string*
</pre>
        </div>
        <p>
          Sends an OPTIONS request to the supplied <code>$uri</code> and returns the supported
          methods as a sequence of strings. Additional <code>$options</code> can be supplied.
        </p>
      </section>

      <section>
        <h3>http:send</h3>
        <div class="exampleInner">
          <pre>
http:send($uri as xs:string, $method as xs:string) as map(*)
http:send($uri as xs:string, $method as xs:string, $body as item()?) as map(*)
http:send($uri as xs:string, $method as xs:string, $body as item()?, $options as map(*)) as map(*)
</pre>
        </div>
        <p>
          Sends a custom HTTP request with the supplied <code>$method</code> and an optional
          <code>$body</code> to the specified <code>$uri</code> and returns the response as a map.
          Additional <code>$options</code> can be supplied.
        </p>
      </section>
    </section>

    <section id='request'>
      <h2>The Request</h2>
      <p>
        An HTTP request consists of a header section and an optional body section.
      </p>

      <section id='request-options'>
        <h3>Request Options</h3>
        <p>
          The following options are available:
        </p>
        <dl>
          <dt><code>status-only</code> (<code>xs:boolean</code>)</dt>
          <dd>Skip body in response. Default: false.</dd>

          <dt><code>follow-redirect</code> (<code>xs:boolean</code>)</dt>
          <dd>Follow HTTP redirects. Default: true.</dd>

          <dt><code>timeout</code> (<code>xs:integer</code>)</dt>
          <dd>Maximum number of seconds to wait for a response.</dd>

          <dt><code>username</code> (<code>xs:string</code>)</dt>
          <dd>Authentication: username.</dd>

          <dt><code>password</code> (<code>xs:string</code>)</dt>
          <dd>Authentication: password.</dd>

          <dt><code>auth-method</code> (<code>xs:string</code>)</dt>
          <dd>Authentication method (Basic, Digest, possibly others). Default: Basic.</dd>

          <dt><code>headers</code> (<code>map(xs:string, xs:string)</code>)</dt>
          <dd>HTTP header fields.</dd>
        </dl>

        <pre class="example" title="GET request with User-Agent header, skip body in response">
          http:get('http://expath.org/xyz', map {
            'status-only': true(),
            'headers': map { 'User-Agent': 'EXPath/1.0' }
          })
        </pre>

        <p>
          Authentication data is processed if a non-empty username is supplied:
        </p>

        <pre class="example" title="DELETE request: user authentication">
          http:delete('http://expath.org/xyz', map {
            'username': 'john',
            'password': '****'
          })
        </pre>

        <p>
          The <a href="#errors"><code>http:options</code></a> error will be raised if the value of
          an option is invalid, or if it has an invalid type.
        </p>
      </section>

      <section id='request-body'>
        <h3>Request Body</h3>
        <p>
          Some HTTP methods (such as POST and PUT, and others that are less common) come with a
          request body. In the functions of this document, it can be supplied via the
          <code>$body</code> parameter.
        </p>
          
        <p>
          If the body is an empty sequence, no data will be sent. Otherwise, the value can have one
          of the following types:
        </p>

        <div class="ednote" title="CG">
          In my last comments on GitHub, I ignored the fact that we need a solution for defining
          Content-Type headers of multipart bodies. This is why I have dropped my idea of
          converting maps to JSON strings.
        </div>

        <ul>
          <li> <code>xs:base64Binary</code>, <code>xs:hexBinary</code>: Value will be sent as binary
            data, media type will be <code>application/octet-stream</code>.</li>
          <li> <code>xs:string</code>: The string will be serialized as UTF-8 octets, media type
            will be <code>text/plain</code>.</li>
          <li> <code>node()</code>: The node will be serialized as XML, media type will be
            <code>application/xml</code>.</li>
          <li> <code>array(*)</code>: Multipart body, media type will be
            <code>multipart/mixed</code>. Each array member:
            <ul>
              <li> must be a map with a <code>headers</code> and a <code>body</code> entry, or</li>
              <li> must have one of the types of this listing.</li>
            </ul>
          </li>
        </ul>

        <p>
          If the supplied value, or the value of a multipart body, has any other type, the
          <a href="#errors"><code>http:body</code></a> error will be raised.
        </p>

        <p>
          The evaluated media type will be assigned as value of the <code>Content-Type</code> header
          unless a value has been supplied by the user. For multipart requests, each media type
          will be sent as <code>Content-Type</code> in the corresponding multipart header section.
        </p>
        
        <pre class="example"
             title="PUT request, single body, implicit Content-Type value: text/plain">
          http:put('http://expath.org/xyz', 'plain and simple')
        </pre>
        
        <pre class="example"
             title="POST request, multipart body, implicit Content-Type value: multipart/mixed">
          http:send('http://expath.org/xyz', 'POST', [
            (: Body 1, implicit Content-Type: application/xml :)
            &lt;persons&gt;...&lt;/persons&gt;,
            (: Body 2, explicit Content-Type: application/x-object :)
            map {
              'headers': map {
                'Content-Disposition': 'form-data; name="uploadedfile"; filename="hello.o"',
                'Content-Type': 'application/x-object'
              },
              'body': xs:hexBinary('414243')
            }
          ])
        </pre>

        <p>
          If no implicit conversion is available for the desired media type, the body can be
          serialized to a string or binary item in advance:
        </p>

        <pre class="example"
             title="POST request, single body, Content-Type value: application/json">
          http:post(
            'http://expath.org/xyz',
            fn:serialize(
              map { 'name': 'John', 'town': 'Houston', 'year': 1984 },
              map { 'method': 'json' }
            ),
            map { 'headers': 'Content-Type': 'application/json' }
          )
        </pre>
      </section>
    </section>

    <section id='response'>
      <h2>The Response</h2>
      <p>
        An HTTP response is returned as a map, which may contain the following entries:
      </p>

      <dl>
        <dt> <code>status</code> (<code>xs:string</code>)</dt>
        <dd> Status code.</dd>

        <dt> <code>message</code> (<code>xs:string</code>)</dt>
        <dd> Status message (also called <i>reason phrase</i>).</dd>

        <dt> <code>headers</code> (<code>map(xs:string, xs:string)</code>)</dt>
        <dd> Response headers. The syntax is identical to the request header.</dd>

        <dt> <code>body</code> (<code>item()?</code>)</dt>
        <dd> Optional response body.</dd>
      </dl>
      
      <pre class="example" title="Response of a GET request">
        map {
          "status": "200",
          "message": "OK",
          "headers": map {
            "Date": "Fri, 31 Dec 1999 23:59:59 GMT",
            "Server": "Apache",
            "Content-Type": "text/plain"
          },
          "body": "Happy new year"
        }
      </pre>

      <div class="ednote" title="CG">
        More than the rest of this spec, the following rules should be taken with a grain of salt.
      </div>

      <p>
        If no body is returned, the body value will be an empty sequence. Otherwise, the value of
        the <code>Content-Type</code> header defines the target type of the body:
      </p>
      
      <ul>
        <li> XML media type: parsed to XML, returned as <code>document-node()</code>.</li>
        <li> Text media type: returned as <code>xs:string</code>.</li>
        <li> Multipart media type: returned as <code>array(*)</code>. Similar to the top-level map,
          each array member will be a map with a <code>headers</code> and a <code>body</code>
          entry. The body will have one of the types of this list.</li>
        <li> otherwise: returned as <code>xs:base64Binary</code>.</li>
      </ul>

      <pre class="example" title="Multipart response">
        map {
          "status": "200",
          "message": "OK",
          "headers": map {
            "Content-Type": "multipart/mixed"
          },
          "body": [
            map {
              "headers" : map {
                "Content-Type": "image/png"
              },
              "body": xs:base64Binary('abcdefgh')
            },
            map {
              "headers" : map {
                "Content-Type": "image/jpeg"
              },
              "body": xs:base64Binary('ijklmnop')
            }
          ]
        }
      </pre>

      <div class="ednote" title="CG">
        Suggestions for controlling parsing of reponse bodies (the result of this discussion should
        actually be specified in <a href="#request-options" class="sectionRef"></a>):
        <dl>
          <dt> <code>override-media-type</code> (<code>xs:boolean</code>):<br></dt>
          <dd>
            Overrides the returned content-type value.<br>
            + Already used in version 1.0 (adopted from XProc, where is was called
              <code>override-content-type</code>).<br>
            – Only works for single bodies.<br>
          </dd>

          <dt> <code>parse-response</code>
            (<code>function(xs:base64Binary, xs:string) as item()</code>):</dt>
          <dd>
            Alternative 1. Override the default parsing behavior. Parameters: body, Content-Type
            value.<br>
            + Could be applied to all parts of a multipart response.<br>
            + Direct access to the binary response stream allows us to handle all potential
              conversion errors.<br>
            – String input may possibly be easier to deal with for many XQuery functions.<br>
            – We may need more header information (Encoding, etc.) to correctly handle the
              result.<br>
          </dd>

          <dt> <code>parse-response</code>
            (<code>function(xs:base64Binary, map(xs:string, xs:string)) as item()</code>):</dt>
          <dd>
            Alternative 2. Parameters: body, response headers.
            + Even more control and information on the sent response.<br>
            – Response handling may get too low-level and technical.<br>
          </dd>

          <dt> <code>parse-response</code> (<code>function(item()) as item()</code>):</dt>
          <dd>
            Alternative 3. Parameters: parsed body (xs:string, xs:base64Binary, document-node())
            + We don’t need to care about binary/string conversion.<br>
            – May fail if server supplies wrong encoding for string conversions.<br>
          </dd>
        </dl>

        <pre class="example" title="Use of parse-response, Alternative 1">
          http:get('http://expath.org/xyz', map {
            "parse-response": function($body, $media-type) {
              if(ends-with($media-type, '/csv') then (
                csv:parse($body)
              ) else if(ends-with($media-type, '/json') then (
                json:parse($body)
              ) else (
                bin:decode-string($body)
              )
            }
          })
        </pre>
      </div>


    </section>

    <section id='errors'>
      <h2>Errors</h2>
      <dl>
        <dt><code>http:body</code></dt>
        <dd>A request body argument has an invalid type.</dd>
        <dt><code>http:options</code></dt>
        <dd>The value of an option is invalid, or has an invalid type.</dd>
      </dl>
    </section>

    <section class="appendix">
      <h2>Acknowledgements</h2>
      <p>
        Many thanks to Robin Berjon for making the production of this specification much simpler
        with his cool ReSpec tool.
      </p>
    </section>
  </body>
</html>
