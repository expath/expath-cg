<!DOCTYPE html>
<html>
  <head>
    <title>HTTP Client Module 2.0</title>
    <meta charset='utf-8'/>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          // the CG
          wg: "EXPath Community Group",
          wgURI: "https://www.w3.org/community/expath/",
          repoURL: "https://github.com/expath/expath-cg/",
          wgPublicList: "public-expath",

          // specification status (e.g. WD, LCWD, NOTE, etc.). CG-DRAFT and CG-FINAL for CG reports
          specStatus: "CG-DRAFT",

          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName: "expath-http-client-2",

          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          //subtitle: "An EXPath Project",

          // if you wish the publication date to be other than today, set this
          // publishDate: "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate: "1977-03-15",
          // previousMaturity: "WD",

          // if there a publicly available Editor's Draft, this is the link
          // edDraftURI: "http://dev.w3.org/2009/dap/ReSpec.js/documentation.html",
          edDraftURI: "https://expath.github.io/expath-cg/specs/http-client-2/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors: [
              { name: "Christian Grün", url: "https://christian-gruen.de/",
                company: "BaseX GmbH", companyURL: "https://basex.org/" },
              { name: "Adam Retter", url: "https://adamretter.org.uk/",
                company: "Evolved Binary", companyURL: "https://evolvedbinary.com/" }
          ],

          // authors, add as many as you like.
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.
          //authors: [
          //],

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI: "",

          // If specified, defines an array of alternate formats in which document is available
          // (e.g., XML, Postscript). The format of the array is:
          // alternateFormats:

          doRDFa: "1.1",

          // TODO once HTTP Client 1.0 module is on W3C EXPath CG - we should submit it to
          // specref.org and remove it from here
          localBiblio: {
            "expath-http-client-10": {
              title: "EXPath HTTP Client Module 1.0",
              href: "https://expath.org/spec/http-client",
              status: "CR",
              publisher: "EXPath",
              authors: [
                "Florent Georges",
              ],
              versions: [
                "expath-http-client-10-20100109",
              ]
            }
          },

          otherLinks: [
            {
	      key: 'Participate',
	      data: [
                {
	          value: 'GitHub expath/expath-cg',
	          href: 'https://github.com/expath/expath-cg/'
	        },
                {
	          value: 'Report an issue',
	          href: 'https://github.com/expath/expath-cg/issues/'
	        }
              ]
	    }
          ]
      };
    </script>
    <style>
      table.minborder {
        border: 1px solid #000000;
        border-collapse: collapse;
        word-wrap: normal;
        overflow-wrap: normal;
        hyphens: manual;
        font-size: smaller;
      }
      table.minborder tbody {
        display: table-row-group;
      }
      table.minborder th {
        border: 1px solid #000000;
        text-align: start;
      }
      table.minborder td {
        border: 1px solid #000000;
        text-align: start;
        padding-left: 5px;
      }
      .option-description {
        vertical-align: top;
      }
      .fake-dfn {
        font-weight: bolder;
        font-style: italic;
      }
      .constants-table th:nth-child(3) {
        text-align: right;
      }
      .constants-table td:nth-child(3) {
        text-align: right;
      }
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification defines an HTTP client interface for XPath based languages, such as but
        not limited to, XQuery, XSLT, and XProc.
        The HTTP client interface is provided through extension functions which perform HTTP
        requests, and associated error codes which define client error states.
      </p>
      <p>Version 2.0 is backward-compliant with the [[expath-http-client-10]]
        and has been designed to be compatible via [[!XPATH-31]] with [[!XQUERY-31]],
        and [[!XSLT-30]].
      </p>
    </section>

    <section id="sotd">
    </section>

    <section id='introduction'>
      <h2>Introduction</h2>
      <p>
        The HTTP Client Module 2.0 provides an HTTP client interface for XPath 3.1 languages.
      </p>
      <p>
        Version 2.0 makes the following design decisions over version 1.0:
      </p>
      <ul>
        <li>Convenience functions for the most frequently used HTTP requests,
          e.g. <a>http:get</a>.</li>
        <li>The functions in this version make use of the new Map and Array types which were added
           to the [[!xpath-datamodel-31]]. This both simplifies the function parameters when making
           an HTTP request, and offers implementers more options for optimizing the parsing of
           requests and responses.</li>
        <li>Version 2.0 defines a single position within all function signatures for each named
          parameter, this provides a cleaner and consistent API when compared to 1.0.</li>
        <li>The entities composing the entity body of the request in version 2.0 are always passed
          as items, compared to 1.0 where they were passed as text nodes of an XML <em>body</em>
          element, this simplifies lazy evaluation and streaming of data for implementers, and
          therefore should offer better performance for users.</li>
      </ul>
      <p>
        An implementation of the module MUST be “backward-compliant” with version 1.0 of the
        <a href='http://expath.org/spec/http-client'>HTTP Client Module</a>.
        We define backward-compliant to mean that both versions of HTTP Client Module live in
        harmony side-by-side, that is to say that their functions, etc. are all in the same
        namespace. We have intentionally designed 2.0 so that it does not override, replace,
        or conflict, with any specific behavior of 1.0. Rather, 2.0 complements 1.0, providing
        a fresh API for newer versions of XPath. The design allows users to conveniently use
        either version, or to use both 2.0 and 1.0 versions together should they wish.
      </p>

      <section>
        <h2>Namespaces and Prefixes</h2>
        <p>
          All functions and errors in this module are assigned to the
          <code>http://expath.org/ns/http-client</code> namespace. In this document, the
          <code>http</code> prefix is bound to this URI.
        </p>
      </section>
    </section>

    <section id='supported-http-versions'>
      <h2>Supported HTTP versions</h2>
      <p>Implementations of this module are expected to support HTTP 1.0 [[!rfc1945]],
        1.1 [[!rfc2616]], and 2.0 [[!rfc7540]]. Unless otherwise explicitly stated in this
        specification, client behavior is expected to conform to the appropriate HTTP RFC.</p>
      <section id="http1-support">
        <h3>HTTP 1.0 Support</h3>
        <p>This module supports all features of HTTP 1.0. Although we do not provide explicit
          functions for the <dfn data-cite="rfc1945#appendix-D.1.3">LINK</dfn> and
          <dfn data-cite="rfc1945#appendix-D.1.4">UNLINK</dfn> HTTP methods, as in practice these
          methods do not appear to be widely used, they are still supported via the
          <a>http:send</a> function.</p>
      </section>
      <section id="http2-support">
        <h3>HTTP/2 Support</h3>
        <p>We acknowledge that HTTP/2 support is currently in its infancy. We have attempted to
          design for a future version of this specification to extend control for HTTP/2 via
          extension points such as <a>$options</a> and further arity functions. We await
          feedback from the users of this specification, with regards to revisions for further
          support of HTTP/2 features.</p>
      </section>
    </section>

    <section id='functions'>
      <h2>Functions</h2>
      <p>
        The functions of this document have several things in common:
      </p>
      <ul>
        <li>All of them have been designed to send HTTP requests to a server, and to return the
          response to the client.</li>
        <li>The first parameter, <a>$uri</a>, contains the URI of the addressed server.</li>
        <li>The <a>$body</a> parameter allows an entity body to be sent in the request.</li>
        <li>The <a>$options</a> parameter is used to control the format, framing and transmission,
            of the request.</li>
        <li>In <a href="#response" class="sectionRef"></a>, the format of the returned result is
          described.</li>
      </ul>

      <p>
        The legacy function <code>http:send-request</code> is still available; it is defined in
        [[!expath-http-client-10]].
      </p>

      <section>
        <h3><dfn>http:get</dfn></h3>
        <div class="exampleInner">
          <pre>
http:get($uri as xs:string) as map(xs:string, item())
http:get($uri as xs:string, $options as map(xs:string, item())) as map(xs:string, item())
</pre>
        </div>
        <p>
          Sends a GET request to the supplied <a>$uri</a> and returns the response as a map.
          Additional <a>$options</a> can be supplied.
        </p>
      </section>

      <section>
        <h3><dfn>http:post</dfn></h3>
        <div class="exampleInner">
          <pre>
http:post($uri as xs:string, $body as item()*) as map(xs:string, item())
http:post($uri as xs:string, $body as item()*, $options as map(xs:string, item())) as map(xs:string, item())
</pre>
        </div>
        <p>
          Sends a POST request with an optional <a>$body</a> to the supplied
          <a>$uri</a> and returns the response as a map. Additional <a>$options</a> can
          be supplied.
        </p>
      </section>

      <section>
        <h3><dfn>http:put</dfn></h3>
        <div class="exampleInner">
          <pre>
http:put($uri as xs:string, $body as item()*) as map(xs:string, item())
http:put($uri as xs:string, $body as item()*, $options as map(xs:string, item())) as map(xs:string, item())
</pre>
        </div>
        <p>
          Sends a PUT request with an optional <a>$body</a> to the supplied <a>$uri</a>
          and returns the response as a map. Additional <a>$options</a> can be supplied.
        </p>
      </section>

      <section>
        <h3><dfn>http:delete</dfn></h3>
        <div class="exampleInner">
          <pre>
http:delete($uri as xs:string) as map(xs:string, item())
http:delete($uri as xs:string, $options as map(xs:string, item())) as map(xs:string, item())
</pre>
        </div>
        <p>
          Sends a DELETE request to the supplied <a>$uri</a> and returns the response as a
          map. Additional <a>$options</a> can be supplied.
        </p>
      </section>

      <section>
        <h3><dfn>http:head</dfn></h3>
        <div class="exampleInner">
          <pre>
http:head($uri as xs:string) as map(xs:string, item())
http:head($uri as xs:string, $options as map(xs:string, item())) as map(xs:string, item())
</pre>
        </div>
        <p>
          Sends a HEAD request to the supplied <a>$uri</a> and returns the response as a map.
          Additional <a>$options</a> can be supplied.
        </p>
      </section>

      <section>
        <h3><dfn>http:options</dfn></h3>
        <div class="exampleInner">
          <pre>
http:options($uri as xs:string) as map(xs:string, item())
http:options($uri as xs:string, $options as map(xs:string, item())) as map(xs:string, item())
</pre>
        </div>
        <p>
          Sends an OPTIONS request to the supplied <a>$uri</a> and returns the response as a
          map. Additional <a>$options</a> can be supplied.
        </p>
      </section>

      <section>
        <h3><dfn>http:trace</dfn></h3>
        <div class="exampleInner">
          <pre>
http:trace($uri as xs:string, $body as item()*) as map(xs:string, item())
http:trace($uri as xs:string, $body as item()*, $options as map(xs:string, item())) as map(xs:string, item())
</pre>
        </div>
        <p>
          Sends a TRACE request with an optional <a>$body</a> to the supplied <a>$uri</a>
          and returns the response as a map. Additional <a>$options</a> can be supplied.
        </p>
      </section>

      <section>
        <h3><dfn>http:send</dfn></h3>
        <div class="exampleInner">
          <pre>
http:send($uri as xs:string, $method as xs:string) as map(xs:string, item())
http:send($uri as xs:string, $method as xs:string, $body as item()*) as map(xs:string, item())
http:send($uri as xs:string, $method as xs:string, $body as item()*, $options as map(xs:string, item())) as map(xs:string, item())
</pre>
        </div>
        <p>
          Sends a custom HTTP request with the supplied $method and an optional
          <a>$body</a> to the specified <a>$uri</a> and returns the response as a map.
          Additional <a>$options</a> can be supplied. The $method should be
          given according to the appropriate specification, for HTTP this means in upper-case
          characters, e.g. <code>GET</code>.
        </p>
      </section>
    </section>

    <section id='request'>
      <h2>The Request</h2>
      <p>
        An HTTP request is made to a URI, and consists of headers and an optional entity body.
      </p>

      <section id="request-uri">
        <h3>The Request URI</h3>
        <p>The request URI is always specified in the <dfn>$uri</dfn> parameter to each function.
          The request URI MUST be a valid URI according to the RFC of the HTTP version that is
          being used for the request. If the URI is invalid, the error <a>http:invalid-uri</a>
          MUST be raised.</p>
      </section>

      <section id='request-options'>
        <h3>Request Options</h3>
        <p>
          The following options can be specified via the <dfn>$options</dfn> parameter:
        </p>

        <table class="minborder">
          <caption>Request Options</caption>
          <colgroup>
            <col span="1">
            <col span="1">
            <col span="1">
            <col span="1" class="option-description">
          </colgroup>
          <thead>
            <tr>
              <th>Option Key</th>
              <th>XDM Type</th>
              <th>Default</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><dfn id="request-http-version">http-version</dfn></td>
              <td><code>xs:string</code></td>
              <td><code>1.1</code></td>
              <td>
                <p>The HTTP Version to use for the request.</p>
                <p>Supported versions are <code>1.0</code>, <code>1.1</code>,
                and <code>2.0</code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn id="request-headers">headers</dfn></td>
              <td><code>map(xs:string, xs:string)</code></td>
              <td><code>empty-sequence()</code></td>
              <td>HTTP header fields.</td>
            </tr>
            <tr>
              <td><dfn>content-encoding</dfn></td>
              <td><code>xs:string</code></td>
              <td><code>empty-sequence()</code></td>
              <td>
                <p>Uses a specific content encoding for the request body.</p>
                <p>Supported encodings are <code>gzip</code>, <code>compress</code>, and
                  <code>deflate</code>.</p>
                <p><strong>NOTE:</strong> Setting this option will override any
                  <code>Content-Encoding</code> HTTP header.</p></td>
            </tr>
            <tr>
              <td><dfn>transfer-encoding</dfn></td>
              <td><code>xs:string</code></td>
              <td>
                <ul>
                  <li><code>empty-sequence()</code> for HTTP 1.0 and 2.0</li>
                  <li><code>chunked</code> for HTTP 1.1</li>
                </ul>
              </td>
              <td>
                <p>Uses a specific transfer encoding for the request body.</p>
                <p>Supported encodings are <code>none</code> and <code>chunked</code>.</p>
                <p><strong>NOTE</strong>: Setting this option will override any
                  <code>Transfer-Encoding</code> HTTP header.</p>
                <p><strong>NOTE</strong>: <code>chunked</code> is not supported by HTTP 1.0 or 2.0,
                  such use MUST raise the <a>http:version</a> error.</p>
              </td>
            </tr>
            <tr>
              <td><dfn>multipart</dfn></td>
              <td><code>xs:boolean</code></td>
              <td><code>false()</code></td>
              <td>
                <p>Indicates if the entity body in <a>$body</a> is a multipart entity body.</p>
              </td>
            </tr>
            <tr>
              <td><dfn>permit-expired-ssl-certificate</dfn></td>
              <td><code>xs:boolean</code></td>
              <td><code>false()</code></td>
              <td>
                <p>This allows HTTPS requests to still work when the server provides an SSL
                  certificate which has expired.</p></td>
            </tr>
            <tr>
              <td><dfn>permit-untrusted-ssl-certificate</dfn></td>
              <td><code>xs:boolean</code></td>
              <td><code>false()</code></td>
              <td>
                <p>This allows HTTPS requests to still work when the server provides an SSL
                  certificate which is not trusted, this may be because the CA (Certificate Authority)
                  is unknown.</p>
              </td>
            </tr>
            <tr>
              <td><dfn>follow-redirect</dfn></td>
              <td><code>xs:integer</code></td>
              <td><code>20</code></td>
              <td>
                <p>Follow HTTP redirects from the server.</p>
                <p>0 indicates that redirects are not to be followed, -1 indicates that redirects
                  are to be followed indefinitely, a specific number indicates the maximum number
                  of redirects to follow.</p>
              </td>
            </tr>
            <tr>
              <td><dfn>timeout</dfn></td>
              <td><code>xs:decimal</code></td>
              <td><code>120</code></td>
              <td>
                <p>Maximum number of seconds to wait for a response. Milliseconds may be specified
                  using the fractional digits of an <code>xs:decimal</code> e.g. <code>0.200</code>
                  is 200 milliseconds.</p>
                <p>The value <code>0</code> indicates that no timeout should be imposed.</p>
                <p>If a negative value is specified, the error code <a>http:invalid-option</a> MUST
                  be raised.</p>
                <p>When a timeout is set, if the server fails to respond within the timeout period,
                  the error <a>http:timeout</a> MUST be raised.</p>
              </td>
            </tr>
            <tr>
              <td><dfn>certificates</dfn></td>
              <td><code>map(xs:string, item()+)+</code></td>
              <td><code>empty-sequence()</code></td>
              <td>
                <p>Options for authenticating the client with the server using certificate(s). The type
                  and use of this option is implementation defined.</p>
                <p><strong>NOTE</strong>: Java implementations SHOULD use the
                  definition defined in
                  <a href="#certificates-option-format-for-java-implementations" class="sectionRef"></a>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn>auth-method</dfn></td>
              <td><code>xs:string</code></td>
              <td><code>Basic</code></td>
              <td>
                <p>HTTP Authentication method.</p>
                <p>Supported values are: <code>Basic</code>, and <code>Digest</code>.</p>
                <p>Implementations are free to define additional authentication methods.</p>
              </td>
            </tr>
            <tr>
              <td><dfn>preemptive-auth</dfn></td>
              <td><code>xs:boolean</code></td>
              <td><code>false</code></td>
              <td>
                <p>Indicates that HTTP authentication should be attempted preemptively, i.e. before a challenge from the server.</p>
                <p>If the chosen <a>auth-method</a> does not support preemptive authentication, then the error <a>http:invalid-option</a> MUST be raised.</p>
              </td>
            </tr>
            <tr>
              <td><dfn>username</dfn></td>
              <td><code>xs:string</code></td>
              <td></td>
              <td>
                <p>Authentication: username.</p>
              </td>
            </tr>
            <tr>
              <td><dfn>password</dfn></td>
              <td><code>xs:string</code></td>
              <td></td>
              <td>
                <p>Authentication: password.</p>
              </td>
            </tr>
            <tr>
              <td><dfn>parse-response</dfn></td>
              <td><code>map(xs:string, *)</code></td>
              <td><code><pre>
map {
  "mode": $http:parse-mode-full,
  "entity": $http:parse-entity-auto
}</pre></code></td>
              <td>
                <p>Controls the parsing of the HTTP response. Entries for the map are detailed in
                  <a href="#parse-response-options" class="sectionRef"></a>.</p>
              </td>
            </tr>
          </tbody>
        </table>

        <section id='parse-response-options'>
          <h4>Parse Response Options</h4>
          <p>
            The following <a>parse-response</a> options can be specified to control HTTP response parsing:
          </p>

          <table class="minborder">
            <caption>parse-response map entries</caption>
            <colgroup>
              <col span="1">
              <col span="1">
              <col span="1">
              <col span="1" class="option-description">
            </colgroup>
            <thead>
              <tr>
                <th>Entry Key</th>
                <th>XDM Type</th>
                <th>Default</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><dfn>mode</dfn></td>
                <td><code>xs:string</code></td>
                <td><code>$http:parse-mode-full</code></td>
                <td>
                  <p>Determines the extent to which the HTTP response is parsed before being returned from the function
                    call as the <a>response map</a>. Parsing of the HTTP response requires processing, so some
                    implementations may be able to optimize for some of the simpler parsing modes. Valid values are:</p>
                  <ul>
                    <li>
                        <a>$http:parse-mode-raw</a>
                        <p>No parsing of the HTTP response is performed. The entire response is returned as
                          <code>xs:base64Binary</code> in the <code>body</code> of the <a>response map</a>, all other
                          entries of the <a>response map</a> are omitted.</p>
                    </li>
                    <li>
                        <a>$http:parse-mode-status</a>
                        <p>Only the <a data-cite="rfc1945#section-6.1">status line</a> from the HTTP response is
                          parsed. Only the <code>http-version</code>, <code>status</code>, and <code>message</code>
                          entries will be present in the <a>response map</a>.</p>
                    </li>
                    <li>
                        <a>$http:parse-mode-headers</a>
                        <p>From the HTTP response, only the <a data-cite="rfc1945#section-6.1">status line</a>,
                          <a data-cite="rfc1945#section-4.3">general headers</a>,
                          <a data-cite="rfc1945#section-6.2">response headers</a>, and
                          <a data-cite="rfc1945#section-7.1">entity headers</a> will all be parsed. All fields apart
                          from the <code>body</code> will be present in the <a>response map</a>.</p>
                    </li>
                    <li>
                      <a>$http:parse-mode-multipart-raw</a>
                      <p>When the HTTP response is a multipart response, first the
                        <a data-cite="rfc1945#section-6.1">status line</a>,
                        <a data-cite="rfc1945#section-4.3">general headers</a>,
                        <a data-cite="rfc1945#section-6.2">response headers</a>, and
                        <a data-cite="rfc1945#section-7.1">entity headers</a> of the HTTP response will be parsed,
                        setting the <code>http-version</code>, <code>status</code>, and <code>message</code> in the
                        <a>response map</a>.</p>
                      <p>Secondly the response's entity body will be minimally parsed; Only extracting each entity from
                        the body in raw form. That is to say, that each multipart entity within the entity body will not
                        have its headers parsed. The entity will be delivered in its raw form in the <code>body</code>
                        entry of the part body and the part body's <code>headers</code> entry will be omitted. Each
                        part body will be set in the <code>body</code> entry of the <a>response map</a>.</p>
                      <p>If the response is not a multipart response, and this mode is set, then the error
                        <a>http:parse</a> MUST be raised.</p>
                    </li>
                    <li>
                      <a>$http:parse-mode-multipart-headers</a>
                      <p>When the HTTP response is a multipart response, first the
                        <a data-cite="rfc1945#section-6.1">status line</a>,
                        <a data-cite="rfc1945#section-4.3">general headers</a>,
                        <a data-cite="rfc1945#section-6.2">response headers</a>, and
                        <a data-cite="rfc1945#section-7.1">entity headers</a> of the HTTP response will be parsed,
                        setting the <code>http-version</code>, <code>status</code>, and <code>message</code> in the
                        <a>response map</a>.</p>
                      <p>Secondly the response's entity body will only be minimally parsed; Only extracting the headers
                        of each entity within the body. That is to say, that each multipart entity within the entity
                        body will have its body ignored. Only the <code>headers</code> of the part body entry will be
                        set, and each part body will be set in the <code>body</code> entry of the <a>response map</a>.</p>
                      <p>If the response is not a multipart response, and this mode is set, then the error
                        <a>http:parse</a> MUST be raised.</p>
                    </li>
                    <li>
                      <a>$http:parse-mode-full</a>
                      <p>The entire HTTP response is parsed automatically according to the rules in
                        <a href="#implicit-response-parsing" class="sectionRef"></a>, and all the entries in the <a>response
                          map</a> are set (apart from the <code>body</code> entry when the HTTP response has no body).</p>
                    </li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td><dfn>entity</dfn></td>
                <td><code>xs:string+</code></td>
                <td><code>$http:parse-entity-auto</code></td>
                <td>
                  <p>Overrides the implicit automatic parsing defined in
                    <a href="#implicit-response-parsing" class="sectionRef"></a>.</p>
                  <p>If this option is specified and the <a>mode</a> is not set to <code>$http:parse-mode-full</code>,
                  then the error <code>http:invalid-option</code> MUST be raised.</p>
                  <p>Where a multipart response is expected, a sequence of values may be specified.
                    If there are less values than multipart parts, then the last value will apply to the remaining
                    multipart parts.</p>
                  <p>Valid values are:</p>
                  <ul>
                    <li>
                      <a>$http:parse-entity-auto</a>
                      <p>Determines the parser based on the the rules defined in
                        <a href="#implicit-response-parsing" class="sectionRef"></a>.</p>
                    </li>
                    <li>
                      <a>$http:parse-entity-xml</a>
                      <p>The entity will be parsed as XML. The result is a <code>document-node()</code>.</p>
                    </li>
                    <li>
                      <a>$http:parse-entity-html-to-xml</a>
                      <p>The entity will be parsed using a HTML parser which can produce XML output.
                        The result is a <code>document-node()</code>.</p>
                      <p>Implementations are not required to support this option. If an implementation does not support
                        this it MUST raise the error <a>http:invalid-option</a>.</p>
                    </li>
                    <li>
                      <a>$http:parse-entity-json</a>
                      <p>The entity will be parsed using a JSON parser. The result is either a <code>map(*)</code>,
                        <code>array(*)</code>, <code>xs:string</code>, <code>xs:double</code>, <code>xs:boolean</code>,
                          or <code>empty-sequence()</code>.</p>
                    </li>
                    <li>
                      <a>$http:parse-entity-text</a>
                      <p>The entity will be parsed as text. The result is an <code>xs:string</code>.</p>
                    </li>
                    <li>
                      <a>$http:parse-entity-raw</a>
                      <p>The entity will be extracted as is. The result is an <code>xs:base64Binary</code>.</p>
                    </li>
                    <li>
                      <a>$http:parse-entity-none</a>
                      <p>The entity will be not be parsed. The result is an <code>empty-sequence()</code>.</p>
                    </li>
                  </ul>
                </td>
              </tr>
            </tbody>
          </table>
        </section>

        <pre class="example" title="GET request with User-Agent header, skip body in response">
          http:get('http://expath.org/xyz', map {
            'status-only': true(),
            'headers': map { 'User-Agent': 'EXPath/1.0' }
          })
        </pre>

        <p>
          Authentication data is processed if a non-empty username is supplied:
        </p>

        <pre class="example" title="DELETE request: user authentication">
          http:delete('http://expath.org/xyz', map {
            'username': 'john',
            'password': '****'
          })
        </pre>

        <p>
          The <a>http:invalid-option</a> error will be raised if the value of an option is invalid,
          or if it has an invalid type.
        </p>
      </section>

      <section id='request-entity-body'>
        <h3>The Request Entity Body</h3>
        <p>
          Some HTTP methods (such as <code>POST</code>, <code>PUT</code>, and others that are
          less common) transmit an <dfn data-cite="rfc1945#section-7.2">entity body</dfn> (often
          colloquially shortened to the "<dfn>Request Body</dfn>"). The functions in this module use
          the <dfn>$body</dfn> parameter to supply this.
        </p>
        <p>
          If the value supplied as the <a>$body</a> parameter is an empty sequence, the
          corresponding request’s <a>entity body</a> will be omitted.
        </p>
        <p>
          If the supplied value, or the value(s) of a multipart entity body, have any other type
          than described in ths section, the <a>http:body</a> error MUST be raised.
          The <a>http:serialize</a> error MUST be raised if an error occurs whilst serializing an
          item (e.g. because a supplied map cannot be serialized as JSON).
        </p>

        <section id='single-entity-body'>
          <h4><dfn>Single Entity Body Request</dfn></h4>
          <p>
            By default, or if the <a>multipart</a> option is set to <code>false</code>,
            a <dfn>single entity</dfn> will be sent in the request’s <a>entity body</a>.
          </p>
          <p>   
            For a <a>single entity</a>, the value for the <a>$body</a> parameter MUST have one of
            the following types:
          </p>

          <dl>
            <dt><code>xs:base64Binary</code>, <code>xs:hexBinary</code></dt>
            <dd>Value will be sent as binary data, the media type will be
              <code>application/octet-stream</code>.</dd>
  
            <dt><code>xs:string</code></dt>
            <dd>The string will be serialized as UTF-8 octets, the media type will be
              <code>text/plain</code>.</dd>
  
            <dt><code>node()</code></dt>
            <dd>The node will be serialized as XML, the media type will be
              <code>application/xml</code>.</dd>
  
            <dt><code>map(*)</code>, <code>array(*)</code></dt>
            <dd>The map will be serialized as JSON, the media type will be
              <code>application/json</code>.</dd>
          </dl>

          <p>
            The evaluated media type will be assigned as the value of the <code>Content-Type</code>
            header unless a value has been supplied by the user in <a href="#request-headers">headers</a>. For multipart
            requests, each media type will be sent as the <code>Content-Type</code> header in the
            corresponding multipart header section.
          </p>

          <pre class="example"
               title="PUT request, single entity, implicit Content-Type value: text/plain">
            http:put('http://expath.org/xyz', 'plain and simple')
          </pre>

          <p>
            If no implicit conversion is available for the desired media type, the body can be
            serialized to a string or binary item in advance, and a custom
            <code>Content-Type</code> header value can be supplied:
          </p>
          <pre class="example"
               title="POST request, single entity, Content-Type value: application/json">
            http:post(
              'http://expath.org/xyz',
              file:read-text('persons.csv'),
              map { 'headers': 'Content-Type': 'text/csv;charset=UTF-8' }
            )
          </pre>
        </section>

        <section id='multipart-entity-body'>
          <h4><dfn>Multipart Entity Body Request</dfn></h4>
          <p>
            <dfn data-cite="rfc1945#section-3.6.2">Multipart Types</dfn> provide for the encapsulation
            of several entities (aka <em>parts</em>) within the request's <a>entity body</a>.
          </p>
          <p>
            An entity body of multiple parts, wherein each part is itself an entity, will be sent
            if the <a>multipart</a> option is set to <code>true</code>.
          </p>
          <p>
            The <a>$body</a> parameter allows one or more entities to be provided;
            Each entity MUST have the type <code>map(xs:string, item())</code>, and the format:
            <code>map { 'headers': $part-headers, 'body': $part-body }</code>.
            If the <code>body</code> entry is not supplied, or if it is an empty sequence,
            the error <a>http:body</a> MUST be raised.
          </p>
          <p>
            The <code>$part-body</code> value will be parsed as a <a>Single Entity</a>.
            If no <code>Content-Type</code> header is supplied in the for the specific part, the resulting
            media type will be assigned.
          </p>
          <pre class="example" title="Multipart Entity Request">
(
  map {
    'headers': map {
      'Content-Disposition': 'form-data; name="file"; filename="covering-letter.md"',
      'Content-Type': 'text/markdown'
    },
    'body': fn:unparsed-text('covering-letter.md')
  },
  map {
    'headers': map {
      'Content-Disposition': 'form-data; name="application-name"'
    },
    'body': 'John Smith'
  },
  map {
    'headers': map {
      'Content-Disposition': 'form-data; name="email"'
    },
    'body': 'john@smith.com'
  }
)
          </pre>
        </section>
  
        <pre class="example"
             title="POST request, multipart entity, implicit Content-Type value: multipart/mixed">
          http:send('http://expath.org/xyz', 'POST', (
            (: Body 1, implicit Content-Type: application/xml :)
            map {
              'body': &lt;persons&gt;...&lt;/persons&gt;,
            }
            (: Body 2, explicit Content-Type: application/x-object :)
            map {
              'headers': map {
                'Content-Disposition': 'form-data; name="uploadedfile"; filename="hello.o"',
                'Content-Type': 'application/x-object'
              },
              'body': xs:hexBinary('414243')
            }
          ))
        </pre>
      </section>
    </section>

    <section id='response'>
      <h2>The Response</h2>
      <p>
        When the HTTP request is made to the server indicated by the request <a>$uri</a>, if the
        server processes the request and responds to the client within the <a>timeout</a> then the
        HTTP response from the server is returned as the result of the function as a map, this is  known as the
        <a>Response Map</a>.</p>
      <p>
        If the server fails to respond to an HTTP request within the <a>timeout</a> then the error
        <a>http:timeout</a> MUST be raised. If the HTTP request cannot be made to the server then
        the error <a>http:network</a> MUST be raised.
      </p>

      <section id="response-map">
        <h3>The Response Map</h3>
        <p>
          The HTTP <dfn>Response Map</dfn> contains the following entries. Optional entries are entirely absent
          from the map if the HTTP response does not contain the corresponding data, for example no body is returned, there will be no <code>body</code> entry.
        </p>

        <table class="minborder">
          <caption>Response Entries</caption>
          <colgroup>
            <col span="1">
            <col span="1">
            <col span="1" class="option-description">
          </colgroup>
          <thead>
            <tr>
              <th>Response Key</th>
              <th>XDM Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><span class="fake-dfn">http-version</span></td>
              <td><code>xs:string</code></td>
              <td>
                <p>The HTTP Version of the response. This may differ from the
                  <a href="#request-http-version">http-version</a> requested!</p>
              </td>
            </tr>
            <tr>
              <td><span class="fake-dfn">status</span></td>
              <td><code>xs:string</code></td>
              <td>
                <p>The HTTP status code.</p>
              </td>
            </tr>
            <tr>
              <td><span class="fake-dfn">message</span></td>
              <td><code>xs:string</code></td>
              <td>
                <p>HTTP reason phrase.</p>
              </td>
            </tr>
            <tr>
              <td><span class="fake-dfn">headers</span></td>
              <td><code>map(xs:string, xs:string)</code></td>
              <td>HTTP response header fields.</td>
            </tr>
            <tr>
              <td><span class="fake-dfn">body</span></td>
              <td><code>item()+</code></td>
              <td>HTTP response body.</td>
            </tr>
          </tbody>
        </table>

        <pre class="example" title="Response of a GET request">
          map {
            "http-version": "1.1",
            "status": "200",
            "message": "OK",
            "headers": map {
              "Date": "Fri, 31 Dec 1999 23:59:59 GMT",
              "Server": "Apache",
              "Content-Type": "text/plain"
            },
            "body": "Happy new year"
          }
        </pre>
      </section>

      <section id="response-entity-body">
        <h3>The Response Entity Body</h3>

        <p>
          HTTP requests sent to the server are under complete the control of the client, as such,
          the client can carefully dictate the data sent in the request. The opposite is true of
          the HTTP response returned from the server, over which the client has no control.
          The majority of the time we can rely on the server to perform as expected and return a
          meaningful response to our request. However, regardless of whether the server is trusted
          or not by the user, we cannot rely on it to always operate correctly. Servers can,
          and often do, return HTTP responses which are not in the spirit of the HTTP request that
          was made. For example, a server is under no obligation to return data in a format that the
          client can understand or even read.
        </p>
        <p>
          The request functions of this module are intentionally biased towards the majority case
          where the server is responding inline with the requests made to it. This bias takes the
          form of implicitly parsing the response entity body from the server before it is returned
          in the response map. This approach eases the job of the developer, by allowing them to work
          with higher-level XDM type representations of the response body as opposed to the raw HTTP
          response data.
        </p>
        <p>
          For those cases where the server is not responding faithfully to the request, or the developer
          needs a greater level of control over the response, the implicit parsing of the response entity
          body can be disabled via the <a>parse-response</a> request option,
          see <a href="#explicit-response-parsing" class="sectionRef"></a>.
        </p>

        <section id="implicit-response-parsing">
          <h4>Implicit Parsing</h4>
          <p>
            When present in the HTTP response, the entity body will be implicitly parsed to an
            XDM type based on the media type set in the <code>Content-Type</code> header of the HTTP
            response headers.
          </p>
          <p>If a response entity body cannot be parsed according to the Conversions detailed below, the error <a>http:parse</a> MUST be raised.</a></p>
          <table class="minborder">
            <caption>Implicit Parsing Conversions (ordered - most significant first)</caption>
            <colgroup>
              <col span="1">
              <col span="1">
              <col span="1" class="option-description">
            </colgroup>
            <thead>
              <tr>
                <th>Media Type Pattern(s)</th>
                <th>XDM Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>multipart/*</code></td>
                <td><code>map(xs:string, item())*</code></td>
                <td>
                  <p>Multipart body, returned as <code>map(xs:string, item())*</code>.
                    The format of the map items is identical to the request format:
                    <code>map { 'headers': $part-headers, 'body': $part-body }</code>.
                    A part body will have one of the remaining types of this list.</p>
                </td>
              </tr>
              <tr>
                <td>
                  <ul>
                    <li><code>application/xml</code></li>
                    <li><code>application/xml-external-parsed-entity</code></li>
                    <li><code>text/xml</code></li>
                    <li><code>text/xml-external-parsed-entity</code></li>
                    <li><code>*/*+xml</code></li>
                  </ul>
                </td>
                <td><code>document-node()</code></td>
                <td>
                  <p>Parsed as XML.</p>
                  <p><b>NOTE</b>: this will logically also include XHTML with the mimetype <code>application/xhtml+xml</code>.
                </td>
              </tr>
              <tr>
                <td><code>application/json</code></td>
                <td>
                  <ul>
                    <li><code>map(*)</code></li>
                    <li><code>array(*)</code></li>
                    <li><code>xs:string</code></li>
                    <li><code>xs:double</code></li>
                    <li><code>xs:boolean</code></li>
                    <li><code>empty-sequence()</code></li>
                  </ul>
                </td>
                <td>
                  <p>Parsed as JSON.</p>
                </td>
              </tr>
              <tr>
                <td><code>text/*</code></td>
                <td><code>xs:string</code></td>
                <td>
                  <p>Parsed as text.</p>
                </td>
              </tr>
              <tr>
                <td><code>*/*</code></td>
                <td><code>xs:base64Binary</code></td>
                <td>
                  <p>No parsing.</p>
                </td>
              </tr>
            </tbody>
          </table>

        <pre class="example" title="Multipart response">
          map {
            "status": "200",
            "message": "OK",
            "headers": map {
              "Content-Type": "multipart/mixed"
            },
            "body": [
              map {
                "headers" : map {
                  "Content-Type": "application/json"
                },
                "body": map { "creator": "John", "year": 2018 }
              },
              map {
                "headers" : map {
                  "Content-Type": "image/png"
                },
                "body": xs:base64Binary('abcdefgh')
              }
            ]
          }
        </pre>
      </section>

        <section id="explicit-response-parsing">
          <h4>Explicit Parsing</h4>
          <p>
            Implicit parsing of the response body can be disabled via the <a>parse-response</a>
            request option, which allows the parsing to be explicitly specified.
          </p>

          <pre class="example" title="XQuery example for parsing raw response body">
            (:~
             : Parses a response and returns the parsed body values.
             : @param $response response (top-level, multipart)
             : @return flat sequence with parsed bodies
             :)
            declare function local:parse(
              $response as map(xs:string, item())
            ) as item()* {
              let $type := $response?headers?Content-Type
              let $body := $response?body
              return if(ends-with($type, '/csv') then (
                csv:parse($body)
              ) else if(ends-with($type, '/json') then (
                json:parse($body)
              ) else if(ends-with($type, '/html') then (
                html:parse($body)
              ) else if(starts-with($type, 'multipart/') then (
                (: parse multipart entries recursively :)
                for $part in $body
                return local:parse($part)
              ) else (
                error(xs:QName('http:parse'), 'Type not supported: ' || $type)
              )
            };

            local:parse(
              http:get('http://expath.org/xyz',
                  map { 'parse-response':
                      map {
                          'entity': $http:parse-entity-raw()
                      }
                  }
              )
            )
          </pre>
        </section>

      </section>

    </section>

    <section id='constants'>
      <h2>Constants</h2>
      <p>This section defines the constants which are defined by the HTTP module. Each constant is
      defined as a variable. The purpose of these constants is to reduce developer error where otherwise
      common strings or values would have to be reproduced.</p>

      <table class="minborder constants-table">
        <caption>Constants</caption>
        <colgroup>
          <col span="1">
          <col span="1">
          <col span="1">
          <col span="1" class="option-description">
        </colgroup>
        <thead>
        <tr>
          <th>Variable</th>
          <th>XDM Type</th>
          <th>Value</th>
        </tr>
        </thead>
        <tbody>
          <tr>
            <td><dfn>$http:parse-entity-auto</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>auto</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-entity-xml</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>xml</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-entity-html-to-xml</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>html2xml</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-entity-json</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>json</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-entity-text</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>text</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-entity-raw</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>raw</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-entity-none</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>none</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-mode-raw</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>raw</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-mode-status</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>status</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-mode-headers</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>headers</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-mode-multipart-raw</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>multipart-raw</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-mode-multipart-headers</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>multipart-headers</code></td>
          </tr>
          <tr>
            <td><dfn>$http:parse-mode-full</dfn></td>
            <td><code>xs:string</code></td>
            <td><code>full</code></td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id='errors'>
      <h2>Errors</h2>
      <p>This section defines and describes the error codes that may be raised by the module.</p> 
      <dl>
        <dt><dfn>http:body</dfn></dt>
        <dd>A request body argument has an invalid type.</dd>
        <dt><dfn>http:version</dfn></dt>
        <dd>A feature is not supported by the specified HTTP version.</dd>
        <dt><dfn>http:invalid-uri</dfn></dt>
        <dd>The URI specified in the <a>$uri</a> parameter to the function is invalid with respect
          to the HTTP version in use.</dd>
        <dt><dfn>http:invalid-option</dfn></dt>
        <dd>The value of an option is invalid, or has an invalid type.</dd>
        <dt><dfn>http:parse</dfn></dt>
        <dd>A response body could not be parsed.</dd>
        <dt><dfn>http:serialize</dfn></dt>
        <dd>A request body could not be serialized.</dd>
        <dt><dfn>http:timeout</dfn></dt>
        <dd>The server did not respond to the request within the timeout period.</dd>
        <dt><dfn>http:network</dfn></dt>
        <dd>A network error occurred whilst making the HTTP request.</dd>
      </dl>
    </section>

    <section class="appendix informative">
      <h2>Certificates Option format for Java implementations</h2>
      <p>This appendix provides an example of how the <a>certificates</a> option SHOULD be specified for Java implementations.</p>
      <pre class="example" title="Certificates with an HTTP Client 2.0 Java Implementation">
"certificates": (
  map {
    "trust": map {
      "keystore": "/x/y/my-trust-store.jks",
      "keystore-password": "trust-store-password",
      "alias": "trust-certificate"
    },
    "client": map {
      "keystore": "/x/y/my-client-store.jks",
      "keystore-password": "client-store-password",
      "alias": "my-certificate",
      "password": "my-certificate-password"
    }
  }
)
      </pre>
      <p><strong>NOTE</strong>: In the above example the <code>alias</code> options are OPTIONAL.</p>
    </section>

    <section class="appendix informative">
      <h2>Acknowledgements</h2>
      <p>
        Many thanks to <a href="https://berjon.com/">Robin Berjon</a> for making the production of
        this specification much simpler by starting the
        <a href="https://github.com/w3c/respec">ReSpec</a> tool project.
      </p>
    </section>
  </body>
</html>
