<?xml version="1.0" encoding="UTF-8"?><!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<!--DO NOT EDIT: GENERATED BY merge-function-specs.xsl-->
<spec xmlns:ex="http://expath.org/ns/xmlspec" role="editors-copy" ex:w3c="true">
   <header>
      <title>Binary Module</title>
      <w3c-designation>w3c-designation</w3c-designation>
      <w3c-doctype>EXPath <phrase diff="del">Candidate</phrase><phrase diff="add">Proposed</phrase>
         Module</w3c-doctype>
      <pubdate>
         <day>3</day>
         <month>October</month>
         <year>2013</year>
      </pubdate>
      <publoc>
         <loc diff="chg" href="http://expath.org/spec/binary/20131003"/>
      </publoc>
      <altlocs>
         <loc href="http://expath.org/spec/binary/editor.xml">XML</loc>
         <loc href="http://expath.org/spec/binary/20131003/diff">Revision Markup</loc>
      </altlocs>
      <latestloc>
         <loc href="http://expath.org/spec/binary"/>
      </latestloc>

      <prevlocs>
         <loc diff="add" href="http://expath.org/spec/binary/20130920"/>
         <loc href="http://expath.org/spec/binary/20130731"/>
         <loc href="http://expath.org/spec/binary/20130312"/>
      </prevlocs>

      <authlist>
         <author role="editor">
            <name>Jirka Kosek</name>
            <email href="mailto:jirka@kosek.cz">jirka@kosek.cz</email>
         </author>
         <author role="editor">
            <name>John Lumley</name>
            <email href="mailto:john@saxonica.com">john@saxonica.com</email>
         </author>
      </authlist>
      <copyright>
         <p>Copyright © 2013 Jirka Kosek and John Lumley, published by the <loc
               href="http://w3.org/community/expath/">EXPath Community Group</loc> under the <loc
               href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor
               License Agreement (CLA)</loc>. A human-readable <loc
               href="http://www.w3.org/community/about/agreements/cla-deed/">summary</loc> is
            available.</p>
         <p>This specification was published by the <loc href="http://www.w3.org/community/expath/"
               >EXPath Community Group</loc>. It is not a W3C Standard nor is it on the W3C
            Standards Track. Please note that under the <loc
               href="http://www.w3.org/community/about/agreements/cla/">W3C Community Contributor
               License Agreement (CLA)</loc> there is a limited opt-out and other conditions apply.
            Learn more about <loc href="http://www.w3.org/community/">W3C Community and Business
               Groups</loc>.</p>
      </copyright>
      <abstract>
         <p>This proposal provides an API for XPath 2.0 to handle binary data. It defines extension
            functions to process data from binary files, including extracting subparts, searching,
            basic binary operations and conversion between binary and structured forms. It has been
            designed to be compatible with XQuery 1.0 and XSLT 2.0, as well as any other XPath 2.0
            usage.</p>
         <p diff="add">The module homepage, with more information, is on the EXPath website at <loc
               href="http://expath.org/modules/binary/">http://expath.org/modules/binary/</loc>.</p>
      </abstract>
      <status>
         <p/>
      </status>
      <langusage>
         <language>en-US</language>
      </langusage>
      <revisiondesc>
         <p>revisiondesc</p>
      </revisiondesc>
   </header>
   <body>
      <div1 id="status">
         <head>Status of this document</head>
         <p>This document is in a<phrase diff="del">n interim</phrase>
            <phrase diff="add">final</phrase> draft stage. Comments are welcomed at <loc
               href="mailto:public-expath@w3.org">public-expath@w3.org</loc> mailing list (<loc
               href="http://lists.w3.org/Archives/Public/public-expath/">archive</loc>).</p>
      </div1>
      <div1 id="introduction">
         <head>Introduction</head>
         <div2 id="namespaces">
            <head>Namespace conventions</head>
            <p>The module defined by this document defines several functions, all contained in the
               namespace <code>http://expath.org/ns/binary</code>. In this document, the
                  <code>bin</code> prefix, when used, is bound to this namespace URI.</p>
            <p>Error codes are defined in the same namespace
                  (<code>http://expath.org/ns/binary</code>), and in this document are displayed
               with the same prefix, <code>bin</code>.</p>
            <p>Binary file I/O uses facilities defined in <phrase diff="del"><loc
                     href="http://expath.org/spec/file">EXPath File Module</loc></phrase>
               <phrase diff="add"><bibref ref="expathfile"/></phrase>, which defines functions in
               the namespace <code>http://expath.org/ns/file</code>. In this document, the
                  <code>file</code> prefix, when used, is bound to this namespace URI.</p>
         </div2>
         <div2 id="error.management">
            <head>Error management</head>
            <p>Error conditions are identified by a code (a <code>QName</code>.) When such an error
               condition is reached in the evaluation of an expression, a dynamic error is thrown,
               with the corresponding error code (as if the standard XPath function
                  <code>error()</code> had been called.)</p>
         </div2>
         <div2 id="type">
            <head>Binary type</head>
            <p>The principal binary type within this module is <code>xs:base64Binary</code>.</p>
            <p>Conversion to and from <code>xs:hexBinary</code> can be performed by casting with
                  <ex:function>xs:hexBinary()</ex:function> and
                  <ex:function>xs:base64Binary()</ex:function>.</p>
            <note>
               <p>As these types are normally implemented as wrappers around byte array structures
                  containing the data, and differ only when being serialized to or parsed from text,
                  such casting in-process should not involve data copying.</p>
            </note>
         </div2>
         <div2 id="testing" diff="add">
            <head diff="add">Test suite</head>
            <p>A suite of test-cases for all the functions defined in this module, in <bibref
                  ref="qt3"/> format, is defined at <bibref ref="tests.binary"/>.</p>
         </div2>
      </div1>
      <div1 id="use-cases">
         <head>Use cases</head>
         <p>Development of this specification was driven by requirements which some XML developers
            regularly encounter in examining or generating data which is presented in binary, or
            other non-textual forms. Some typical use cases include:</p>
         <ulist>
            <item>
               <p>Getting the dimensions of an image file.</p>
            </item>
            <item>
               <p>Extracting image metadata.</p>
            </item>
            <item>
               <p>Processing images embedded as base64 encodings within a SOAP message.</p>
            </item>
            <item>
               <p>Processing legacy text files which use different encodings in separate
                  sections.</p>
            </item>
            <item>
               <p>Generating PDF files from SVG graphical data.</p>
            </item>
         </ulist>
         <div2 id="example-JPEG">
            <head>Example – finding JPEG size</head>
            <p>As an example, the following code reads the binary form of a JPEG image file,
               searches for the 'Start of Frame/DCT' segment, and unpacks the relevant binary
               sections to integers of height and width:</p>
            <eg xml:space="preserve">
&lt;xsl:variable name="binary" select="file:read-binary(@href)" as="xs:base64Binary"/&gt;
&lt;xsl:variable name="location" select="bin:find($binary,0,bin:hex('FFC0'))"/&gt;
&lt;size width="{bin:unpack-unsigned-integer($binary,$location+5,2,'most-significant-first')}"
      height="{bin:unpack-unsigned-integer($binary,$location+7,2,'most-significant-first')}"/&gt;
               
      =&gt; &lt;size width="377" height="327"/&gt;</eg>
            <p>(The <code>'most-significant-first'()</code> argument ensures the numeric conversion
               is 'big-endian', which is the format in JPEG.)</p>
         </div2>
         <div2 id="example-ASN1">
            <head>Example – reading and writing variable length ASN.1 integers</head>
            <p><bibref ref="asn1"/> defines several formats for identifying and encoding
               arbitrary-sized telecommunications data as streams of octets. Many of these forms
               specify the length of data as part of their encoding. For example, in the Basic
               Encoding Rules, an integer is represented as the following series of octets:</p>
            <ulist>
               <item>
                  <p>Type - 1 octet - in this case the value <code>0x02</code></p>
               </item>
               <item>
                  <p>Length – &gt;=1 octet – the number of octets in the integer value. The length
                     field itself can be variable in length - to accomodate VERY large integers
                     (requiring more than 127 octets to represent, e.g. 2048-bit crypto keys.)</p>
               </item>
               <item>
                  <p>Payload – &gt;=0 octets – the octets of the integer value in
                     most-significant-first order.</p>
               </item>
            </ulist>
            <p>To generate such a representation for an integer from XSLT/XPath, the following code
               might be used:</p>
            <eg xml:space="preserve">
 &lt;xsl:function name="bin:int-octets" as="xs:integer*"&gt;
    &lt;xsl:param name="value" as="xs:integer"/&gt;
    &lt;xsl:sequence
            select="if($value ne 0) then (bin:int-octets($value idiv 256),$value mod 256) else ()"/&gt;
 &lt;/xsl:function&gt;
 &lt;xsl:function name="bin:encode-ASN-integer" as="xs:base64Binary"&gt;
     &lt;xsl:param name="int" as="xs:integer"/&gt;
     &lt;xsl:variable name="octets" select="bin:int-octets($int)"/&gt;
     &lt;xsl:variable name="length-octets"
         select="let $l := count($octets) return
         (if($l le 127) then $l 
         else (let $lo := bin:int-octets($l) return (128+count($lo),$lo)))"/&gt;
     &lt;xsl:sequence select="bin:from-octets((2,$length-octets,$octets))"/&gt;
 &lt;/xsl:function&gt;</eg>
            <p>The function <code>bin:int-octets()</code> returns a sequence of all the
               'significant' octets of the integer (i.e. eliminating leading 'zeroes') in
               most-significant order. Examples of the encoding are: </p>
            <eg xml:space="preserve">
 bin:encode-ASN-integer(0) =&gt; "AgA="
 bin:encode-ASN-integer(1234) =&gt; "AgIE0g=="
 bin:encode-ASN-integer(123456789123456789123456789123456789) =&gt; "Ag8XxuPAMviQRa10ZoQEXxU="
               
 bin:encode-ASN-integer(123456789.. 900 digits... 123456789) =&gt; "AoIBdgaTo....EBF8V"</eg>
            <p>The first example requires no octets to encode zero, hence its octets are
                  <code>2,0</code>. Both the second and third examples can be represented in less
               than 128 octets (2 and 15 respectively), so length is encoded as a single octet. The
               first three octets of the result for the last example, which encodes a 900-digit
               integer, are: <code>2,130,1</code> indicating that the data is represented by
               (130-128) * 256 + 1 = 513 octets and the length required two octets to encode.</p>
            <p>Decoding is a matter of compound use of the integer decoding function:</p>
            <eg xml:space="preserve">
 &lt;xsl:function name="bin:decode-ASN-integer" as="xs:integer"&gt;
     &lt;xsl:param name="in" as="xs:base64Binary"/&gt;
     &lt;xsl:sequence
         select="let $lo := bin:unpack-unsigned-integer($in,1,1,'BE') return (
         if($lo le 127) then bin:unpack-unsigned-integer($in,2,$lo,'BE') 
            else (let $lo2 := $lo - 128, $lo3 := bin:unpack-unsigned-integer($in,2,$lo2,'BE') return
            bin:unpack-unsigned-integer($in,2+$lo2,$lo3,'BE')))"
      /&gt;
 &lt;/xsl:function&gt;               </eg>
            <p>(all numbers in ASN are 'big-endian') and the examples from above reverse:</p>
            <eg xml:space="preserve">
 bin:decode-ASN-integer(xs:base64Binary("AgA=")) =&gt; 0
 bin:decode-ASN-integer(xs:base64Binary("AgIE0g==")) =&gt; 1234
 bin:encode-ASN-integer(xs:base64Binary("Ag8XxuPAMviQRa10ZoQEXxU=")) 
     =&gt; 123456789123456789123456789123456789              
 bin:encode-ASN-integer(xs:base64Binary("AoIBdgaTo....EBF8V")) 
     =&gt; 123456789.. 900 digits... 123456789                </eg>
         </div2>
      </div1>
      <div1 id="loading">
         <head>Loading and saving binary data</head>
         <p>This module defines no specific functions for reading and writing binary data from
            files. The EXPath File Module <bibref ref="expathfile"/> provides three suitable
            functions:</p>
         <ulist>
            <item>
               <p>
                  <ex:function><a href="http://expath.org/spec/file#d3e541"
                     >file:append-binary</a></ex:function>($file as <ex:type>xs:string</ex:type>,
                  $value as <ex:type>xs:base64Binary</ex:type>) as
                     <ex:type>empty-sequence()</ex:type>. Appends a Base64 item as binary to a
                  file.</p>
            </item>
            <item>
               <p>
                  <ex:function><a href="http://expath.org/spec/file#d3e954"
                     >file:read-binary</a></ex:function>($file as <ex:type>xs:string</ex:type>) as
                     <ex:type>xs:base64Binary</ex:type>. Returns the content of a file in its Base64
                  representation.</p>
            </item>
            <item>
               <p>
                  <ex:function><a href="http://expath.org/spec/file#d3e1359"
                     >file:write-binary</a></ex:function>($file as <ex:type>xs:string</ex:type>,
                  $value as <ex:type>xs:base64Binary</ex:type>) as
                     <ex:type>empty-sequence()</ex:type>. Writes a Base64 item as binary to a file.
               </p>
            </item>
         </ulist>
         <p>There may be an argument for a positioned file:read-binary($file as
               <ex:type>xs:string</ex:type>,$offset as <ex:type>xs:integer</ex:type>), for access
            into large files without total read.</p>
      </div1>

      <div1 id="constants">
         <head>Defining 'constants' and conversions</head>
         <p>Users of the package may need to define binary 'constants' within their code or examine
            the basic octets. The following functions support these:</p>
         <div2 id="hex">
            <head>bin:hex</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the binary form of the set of octets written as a sequence of
                        (ASCII) hex digits ([0-9A-Fa-f]).</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="hex" return-type="xs:base64Binary?" isOp="no" prefix="bin">
                              <arg name="in" type="xs:string?"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>
                        <code>$in</code> will be effectively zero-padded from the left to generate
                        an integral number of octets, i.e. an even number of hexadecimal digits. If
                           <code>$in</code> is an empty string, then the result will be a
                           <code>xs:base64Binary</code> with no embedded data.</p>
                     <p>Byte order in the result follows (per-octet) character order in the
                        string.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.nonNumberChar"/> is raised if <code>$in</code> cannot be
                        parsed as a hexadecimal number.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p>When the input string has an even number of characters, this function
                        behaves similarly to the double cast
                              <code>xs:base64Binary(xs:hexBinary(<em>$string</em>))</code>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Examples</label>
                  <def>

                     <eg xml:space="preserve">bin:hex('11223F4E') =&gt; "ESI/Tg=="</eg>


                     <eg xml:space="preserve">bin:hex('1223F4E') =&gt; "ASI/Tg=="</eg>

                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="binary">
            <head>bin:bin</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the binary form of the set of octets written as a sequence of
                        (8-wise) (ASCII) binary digits ([01]).</p>

                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="bin" return-type="xs:base64Binary?" isOp="no" prefix="bin">
                              <arg name="in" type="xs:string?"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>
                        <code>$in</code> will be effectively zero-padded from the left to generate
                        an integral number of octets. If <code>$in</code> is an empty string, then
                        the result will be a <code>xs:base64Binary</code> with no embedded data.</p>
                     <p>Byte order in the result follows (per-octet) character order in the
                        string.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.nonNumberChar"/> is raised if <code>$in</code> cannot be
                        parsed as a binary number.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Examples</label>
                  <def>

                     <eg xml:space="preserve">bin:bin('1101000111010101') =&gt; "0dU="</eg>


                     <eg xml:space="preserve">bin:bin('1000111010101') =&gt; "EdU="</eg>

                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="octal">
            <head>bin:octal</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the binary form of the set of octets written as a sequence of
                        (ASCII) octal digits ([0-7]).</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="octal" return-type="xs:base64Binary?" isOp="no" prefix="bin">
                              <arg name="in" type="xs:string?"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>
                        <code>$in</code> will be effectively zero-padded from the left to generate
                        an integral number of octets. If <code>$in</code> is an empty string, then
                        the result will be a <code>xs:base64Binary</code> with no embedded data.</p>
                     <p>Byte order in the result follows (per-octet) character order in the
                        string.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.nonNumberChar"/> is raised if <code>$in</code> cannot be
                        parsed as an octal number.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Examples</label>
                  <def>

                     <eg xml:space="preserve">bin:octal('11223047') =&gt; "JSYn"</eg>

                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="to-octets">
            <head>bin:to-octets</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns binary data as a sequence of octets.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="to-octets" return-type="xs:integer*" isOp="no" prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>If <code>$in</code> is a zero length binary data then the empty sequence is
                        returned.</p>
                     <p>Octets are returned as integers from 0 to 255.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="from-octets">
            <head>bin:from-octets</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Converts a sequence of octets into binary data.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="from-octets" return-type="xs:base64Binary" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:integer*"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Octets are integers from 0 to 255.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        zero-sized binary data.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.largeOctet"/> is raised if one of the octets lies outside
                        the range 0 - 255. </p>
                  </def>
               </gitem>
            </glist>
         </div2>
      </div1>

      <div1 id="basic-operations">
         <head>Basic operations</head>
         <div2 id="length">
            <head>bin:length</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>The <code>bin:length</code> function returns the size of binary data in
                        octets.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="length" return-type="xs:integer" isOp="no" prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Returns the size of binary data in octets.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="part">
            <head>bin:part</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>The <code>bin:part</code> function returns a specified part of binary
                        data.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p><example role="signature">
                           <proto name="part" return-type="xs:base64Binary?" isOp="no" prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="offset" type="xs:integer"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="part" return-type="xs:base64Binary?" isOp="no" prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="offset" type="xs:integer"/>
                              <arg name="size" type="xs:integer"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Returns a section of binary data starting at the <code>$offset</code> octet.
                        If <code>$size</code> is defined, the size of the returned binary data is
                           <code>$size</code> octets. If <code>$size</code> is absent, all remaining
                        data from <code>$offset</code> is returned.</p>
                     <p>The <code>$offset</code> is zero based.</p>
                     <p>The values of <code>$offset</code> and <code>$size</code>
                        <rfc2119>must</rfc2119> be non-negative integers.</p>
                     <p>It is a dynamic error if <code>$offset</code> + <code>$size</code> is larger
                        than the size of the binary data in <code>$in</code>.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.offsetNegative"/> is raised if <code>$offset</code> is
                        negative.</p>
                     <p><bibref ref="error.sizeNegative"/> is raised if <code>$size</code> is
                        negative.</p>
                     <p><bibref ref="error.offsetBeyondEnd"/> is raised if <code>$offset +
                           $size</code> extends beyond the binary data of <code>$in</code>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p>Note that <code>fn:subsequence()</code> and <code>fn:substring()</code>
                        <bibref ref="fo11"/> both use <code>xs:double</code> for offset and size –
                        this is a legacy from XPath 1.0.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Examples</label>
                  <def>

                     <p>Testing whether <code>$data</code> variable starts with binary content
                        consistent with a PDF file:</p>
                     <eg xml:space="preserve">bin:part($data, 0, 4) eq bin:hex("25504446")</eg>
                     <p><code>25504446</code> is the magic number for PDF files: it is the US-ASCII
                        encoded hexadecimal value for <code>%PDF</code>.</p>

                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="join">
            <head>bin:join</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the binary data created by concatenating the binary data items in a
                        sequence.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="join" return-type="xs:base64Binary" isOp="no" prefix="bin">
                              <arg name="in" type="xs:base64Binary*"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>The function returns an <code>xs:base64Binary</code> created by
                        concatenating the items in the sequence <code>$in</code>, in order.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        a binary item containing no data bytes.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="insert-before">
            <head>bin:insert-before</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>The <code>bin:insert-before</code> function inserts additional binary data
                        at a given point in other binary data.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="insert-before" return-type="xs:base64Binary?" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="offset" type="xs:integer"/>
                              <arg name="extra" type="xs:base64Binary?"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Returns binary data consisting sequentially of the data from
                           <code>$in</code> upto and including the <code>$offset - 1</code> octet,
                        followed by all the data from <code>$extra</code>, and then the remaining
                        data from <code>$in</code>.</p>
                     <p>The <code>$offset</code> is zero based.</p>
                     <p>The value of <code>$offset</code>
                        <rfc2119>must</rfc2119> be a non-negative integer.</p>
                     <p>It is a dynamic error if <code>$offset</code> is larger than the size of the
                        binary data in <code>$in</code>.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                     <p>If the value of <code>$extra</code> is the empty sequence, the function
                        returns <code>$in</code>.</p>
                     <p>If <code>$offset eq 0</code> the result is the binary concatenation of
                           <phrase diff="del"><code>$in</code> and <code>$extra</code></phrase>
                        <phrase diff="add"><code>$extra</code> and <code>$in</code>, i.e. equivalent
                           to <code>bin:join(($extra,$in))</code></phrase>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.offsetNegative"/> is raised if <code>$offset</code> is
                        negative.</p>
                     <p><bibref ref="error.offsetBeyondEnd"/> is raised if <code>$offset</code>
                        extends beyond the binary data of <code>$in</code>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p>Note that under non-error conditions and when <code>$offset gt 0</code> the
                        function is equivalent to:</p>
                     <eg>bin:join((bin:part($in,0,$offset - 1),$extra,bin:part($in,$offset)))</eg>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="pad-left">
            <head>bin:pad-left</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the binary data created by padding <code>$in</code> with
                           <code>$size</code> octets from the left. The padding octet values are
                           <code>$octet</code> or zero if omitted.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p><example role="signature">
                           <proto name="pad-left" return-type="xs:base64Binary?" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="size" type="xs:integer"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="pad-left" return-type="xs:base64Binary?" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="size" type="xs:integer"/>
                              <arg name="octet" type="xs:integer"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>The function returns an <code>xs:base64Binary</code> created by padding the
                        input with <code>$size</code> octets <em>in front of</em> the input. If
                           <code>$octet</code> is specified, the padding octets each have that
                        value, otherwise they are blank.</p>
                     <p><code>$size</code>
                        <rfc2119>must</rfc2119> be a non-negative integer.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.sizeNegative"/> is raised if <code>$size</code> is
                        negative.</p>
                     <p><bibref ref="error.largeOctet"/> is raised if <code>$octet</code> lies
                        outside the range 0 - 255. </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p>Padding with a non-zero octet value can also be accomplished by the XPath
                        expressions:</p>
                     <eg xml:space="preserve">bin:join(($in, bin:from-octets((1 to $pad-length) ! $pad-octet))) [XPath 3.0]</eg>
                     <eg xml:space="preserve">bin:join(($in, bin:from-octets(for $ i in (1 to $pad-length) return $pad-octet))) [XPath 2.0]</eg>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="pad-right">
            <head>bin:pad-right</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the binary data created by padding <code>$in</code> with
                           <code>$size</code> blank octets from the right. The padding octet values
                        are <code>$octet</code> or zero if omitted.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p><example role="signature">
                           <proto name="pad-right" return-type="xs:base64Binary?" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="size" type="xs:integer"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="pad-right" return-type="xs:base64Binary?" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="size" type="xs:integer"/>
                              <arg name="octet" type="xs:integer"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>The function returns an <code>xs:base64Binary</code> created by padding the
                        input with <code>$size</code> blank octets <em>after</em> the input. If
                           <code>$octet</code> is specified, the padding octets each have that
                        value, otherwise they are blank.</p>
                     <p><code>$size</code>
                        <rfc2119>must</rfc2119> be a non-negative integer.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.sizeNegative"/> is raised if <code>$size</code> is
                        negative.</p>
                     <p><bibref ref="error.largeOctet"/> is raised if <code>$octet</code> lies
                        outside the range 0 - 255. </p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p>Padding with a non-zero octet value can also be accomplished by the XPath
                        expressions:</p>
                     <eg xml:space="preserve">bin:join((bin:from-octets((1 to $pad-length) ! $pad-octet),$in))  [XPath 3.0]</eg>
                     <eg xml:space="preserve">bin:join((bin:from-octets(for $ i in (1 to $pad-length) return $pad-octet),$in))  [XPath 2.0]</eg>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="index-of">
            <head>bin:find</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the first location in <code>$in</code> of <code>$search</code>,
                        starting at the <code>$offset</code> octet.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="find" return-type="xs:integer?" isOp="no" prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="offset" type="xs:integer"/>
                              <arg name="search" type="xs:base64Binary"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>The function returns the first location of the binary search sequence in the
                        input, or if not found, the empty sequence.</p>
                     <p>The search sequence cannot be 'empty'.</p>
                     <p>The value of <code>$offset</code>
                        <rfc2119>must</rfc2119> be a non-negative integer.</p>
                     <p>The <code>$offset</code> is zero based.</p>
                     <p>The returned location is zero based.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.offsetNegative"/> is raised if <code>$offset</code> is
                        negative.</p>
                     <p><bibref ref="error.offsetBeyondEnd"/> is raised if <code>$offset</code>
                        extends beyond the binary data of <code>$input</code>.</p>
                     <p><bibref ref="error.emptySearch"/> is raised if <code>$search</code> is empty
                        binary data.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p>Finding all the matches can be accomplished with simple recursive
                        application:</p>
                     <eg xml:space="preserve">
&lt;xsl:function name="bin:find-all" as="xs:integer*"&gt;
     &lt;xsl:param name="data" as="xs:base64Binary?"/&gt;
     &lt;xsl:param name="offset" as="xs:integer"/&gt;
     &lt;xsl:param name="pattern" as="xs:base64Binary"/&gt;
     &lt;xsl:sequence
         select="let $found := bin:find($data,$offset,$pattern) return
         if($found) then ($found,
             if($found + 1 lt bin:length($data)) then bin:find-all($data,$found + 1,$pattern) else ())
             else ()"/&gt;
&lt;/xsl:function&gt;</eg>
                  </def>
               </gitem>
            </glist>
         </div2>

      </div1>

      <div1 id="text-encoding">
         <head>Text decoding and encoding</head>
         <div2 id="decode-string">
            <head>bin:decode-string</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Decodes binary data as a string in a given encoding.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p><example role="signature">
                           <proto name="decode-string" return-type="xs:string?" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="encoding" type="xs:string"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="decode-string" return-type="xs:string?" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="encoding" type="xs:string"/>
                              <arg name="offset" type="xs:integer"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="decode-string" return-type="xs:string?" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="encoding" type="xs:string"/>
                              <arg name="offset" type="xs:integer"/>
                              <arg name="size" type="xs:integer"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>If <code>$offset</code> and <code>$size</code> are provided, the
                           <code>$size</code> octets from <code>$offset</code> are decoded. If
                           <code>$offset</code> alone is provided, octets from <code>$offset</code>
                        to the end are decoded, otherwise the entire octet sequence is used.</p>
                     <p>The <code>$encoding</code> argument is the name of an encoding. The values
                        for this attribute follow the same rules as for the <code>encoding</code>
                        attribute in an XML declaration. The only values which every implementation
                        is <rfc2119>required</rfc2119> to recognize are <code>utf-8</code> and
                           <code>utf-16</code>.</p>
                     <p>The values of <code>$offset</code> and <code>$size</code>
                        <rfc2119>must</rfc2119> be non-negative integers.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                     <p><code>$offset</code> is zero based.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.offsetNegative"/> is raised if <code>$offset</code> is
                        negative.</p>
                     <p><bibref ref="error.sizeNegative"/> is raised if <code>$size</code> is
                        negative.</p>
                     <p><bibref ref="error.offsetBeyondEnd"/> is raised if <code>$offset</code> +
                           <code>$size</code> - 1 extends beyond the binary data of
                        <code>$in</code>.</p>
                     <p><bibref ref="error.unknownEncoding"/> is raised if <code>$encoding</code> is
                        invalid or not supported by the implementation.</p>
                     <p><bibref ref="error.encoding"/> is raised if there is an error or malformed
                        input during decoding the string. Additional information about the error may
                        be passed though suitable error reporting mechanisms - this is
                        implementation-dependant.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Examples</label>
                  <def>

                     <p>Testing whether <code>$data</code> variable starts with binary content
                        consistent with a PDF file:</p>
                     <eg xml:space="preserve">bin:decode-string($data, 'UTF-8', 0, 4) eq '%PDF'</eg>
                     <p>The first four characters of a PDF file are <code>'%PDF'</code>.</p>

                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="encode-string">
            <head>bin:encode-string</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Encodes a string into binary data using a given encoding.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="encode-string" return-type="xs:base64Binary?" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:string?"/>
                              <arg name="encoding" type="xs:string"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>The <code>$encoding</code> argument is the name of an encoding. The values
                        for this attribute follow the same rules as for the <code>encoding</code>
                        attribute in an XML declaration. The only values which every implementation
                        is <rfc2119>required</rfc2119> to recognize are <code>utf-8</code> and
                           <code>utf-16</code>.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.encoding"/> is raised if <code>$encoding</code> is
                        invalid or not supported by the implementation.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
      </div1>

      <div1 id="numeric-packing">
         <head>Packing and unpacking of encoded numeric values</head>
         <div2 id="endianness">
            <head>Number 'endianness'</head>
            <p>Packing and unpacking numeric values can be performed in 'most-significant-first'
               ('big-endian') or 'least-significant-first' ('little-endian') octet order. The
               default is <emph>'most-significant-first'</emph>. The functions have an optional
               parameter <code>$octet-order</code> whose string value controls the order.
               Least-significant-first order is indicated by any of the values
                  <code>least-significant-first</code>, <code>little-endian</code> or
                  <code>LE</code>. Most-significant-first order is indicated by any of the values
                  <code>most-significant-first</code>, <code>big-endian</code> or
               <code>BE</code>.</p>
         </div2>
         <div2 id="integer">
            <head>Integer representation</head>
            <p/>
            <p>Integers within binary data are represented, or assumed to be represented, as an
               integral number of octets. Integers where <code>$length</code> is greater than 8
               octets (and thus not representable as a <code>long</code>) might be expected in some
               situations, e.g. encryption. Whether the range of integers is limited to
                  <code>±2^63</code> may be implementation-dependant.</p>
         </div2>
         <div2 id="floating">
            <head>Representation of floating point numbers</head>
            <p>Care should be taken with the packing and unpacking of floating point numbers
                  (<code>xs:float</code> and <code>xs:double</code>). The binary representations are
               expected to correspond with those of the IEEE single/double-precision 32/64-bit
               floating point types <bibref ref="ieee754"/>. Consequently they will occupy 4 or 8
               octets when packed.</p>
            <p>Positive and negative infinities are supported. <code>INF</code> maps to <code>0x7f80
                  0000</code> (float), <code>0x7ff0 0000 0000 0000</code> (double).
                  <code>-INF</code> maps to <code>0xff80 0000</code> (float), <code>0xfff0 0000 0000
                  0000</code> (double).</p>
            <p>Negative zero (<code>0x8000 0000 0000 0000</code> double, <code>0x8000 0000</code>
               float) encountered during unpacking will yield negative zero forms (e.g.
                  <code>-xs:double(0.0)</code>) and negative zeros will be written as a result of
               packing.</p>
            <p><bibref ref="xmlschema1.1"/> provides only one form of NaN which corresponds to a
               'quiet' NaN with zero payload of <bibref ref="ieee754"/> with forms <code>0x7fc0
                  0000</code> (float), <code>0x7ff8 0000 0000 0000</code> (double). These are the
               bit forms that will be packed. 'Signalling' NaN values (<code>0x7f80 0001</code>
               -&gt; <code>0x7fbf ffff</code> or <code>0xff80 0001</code> -&gt; <code>0xffbf
                  ffff</code>, <code>0x7ff0 0000 0000 0001</code> -&gt; <code>0x7ff7 ffff ffff
                  ffff</code> or <code>0xfff0 0000 0000 0001</code> -&gt; <code>0xfff7 ffff ffff
                  ffff</code>) encountered during unpacking will be replaced by 'quiet' NaN. Any
               low-order payload in a unpacked quiet NaN is also zeroed. </p>
         </div2>
         <div2 id="pack-double">
            <head>bin:pack-double</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the 8-octet binary representation of a <loc
                           href="http://www.w3.org/TR/xmlschema-2/#double">double</loc> value.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p><example role="signature">
                           <proto name="pack-double" return-type="xs:base64Binary" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:double"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="pack-double" return-type="xs:base64Binary" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:double"/>
                              <arg name="octet-order" type="xs:string"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Most-significant-octet-first number representation is assumed unless the
                           <code>$octet-order</code> parameter is specified. Acceptable values for
                           <code>$octet-order</code> are described in <specref ref="endianness"
                        />.</p>
                     <p>The binary representation will correspond with that of the IEEE
                        double-precision 64-bit floating point type <bibref ref="ieee754"/>. For
                        more details see <specref ref="floating"/>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.endianness"/> is raised if the value
                           <code>$octet-order</code> is unrecognized.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="pack-float">
            <head>bin:pack-float</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the 4-octet binary representation of a <loc
                           href="http://www.w3.org/TR/xmlschema-2/#float">float</loc> value.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p><example role="signature">
                           <proto name="pack-float" return-type="xs:base64Binary" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:float"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="pack-float" return-type="xs:base64Binary" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:float"/>
                              <arg name="octet-order" type="xs:string"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Most-significant-octet-first number representation is assumed unless the
                           <code>$octet-order</code> parameter is specified. Acceptable values for
                           <code>$octet-order</code> are described in <specref ref="endianness"
                        />.</p>
                     <p>The binary representation will correspond with that of the IEEE
                        single-precision 32-bit floating point type <bibref ref="ieee754"/>. For
                        more details see <specref ref="floating"/>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.endianness"/> is raised if the value
                           <code>$octet-order</code> is unrecognized.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="pack-integer">
            <head>bin:pack-integer</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the <em>twos-complement</em> binary representation of an integer
                        value treated as <code>$size</code> octets long. Any 'excess' high-order
                        bits are discarded.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p><example role="signature">
                           <proto name="pack-integer" return-type="xs:base64Binary" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:integer"/>
                              <arg name="size" type="xs:integer"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="pack-integer" return-type="xs:base64Binary" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:integer"/>
                              <arg name="size" type="xs:integer"/>
                              <arg name="octet-order" type="xs:string"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Most-significant-octet-first number representation is assumed unless the
                           <code>$octet-order</code> parameter is specified. Acceptable values for
                           <code>$octet-order</code> are described in <specref ref="endianness"
                        />.</p>
                     <p>Specifying a <code>$size</code> of zero yields an empty binary data.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.endianness"/> is raised if the value
                           <code>$octet-order</code> is unrecognized.</p>
                     <p><bibref ref="error.sizeNegative"/> is raised if <code>$size</code> is
                        negative.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p>If the integer being packed has a maximum precision of <code>$size</code>
                        octets, then signed/unsigned versions are not necessary. If the data is
                        considered unsigned, then the most significant bit of the bottom
                           <code>$size</code> octets has a normal positive (<code>2^(8 *$size -
                           1)</code>) meaning. If it is considered to be a signed value, then the
                        MSB and all the higher order, discarded bits will be '1' for a negative
                        value and '0' for a positive or zero. If this function were to check the
                        'sizing' of the supplied integer against the packing size, then any values
                        of MSB and the discarded higher order bits other than 'all 1' or 'all 0'
                        would constitute an error. <em>This function does not perfom such
                           checking.</em></p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="unpack-double">
            <head>bin:unpack-double</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Extract <loc href="http://www.w3.org/TR/xmlschema-2/#double">double</loc>
                        value stored at the particular offset in binary data.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p><example role="signature">
                           <proto name="unpack-double" return-type="xs:double" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                              <arg name="offset" type="xs:integer"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="unpack-double" return-type="xs:double" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                              <arg name="offset" type="xs:integer"/>
                              <arg name="octet-order" type="xs:string"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Most-significant-octet-first number representation is assumed unless the
                           <code>$octet-order</code> parameter is specified. Acceptable values for
                           <code>$octet-order</code> are described in <specref ref="endianness"
                        />.</p>
                     <p>The value of <code>$offset</code>
                        <rfc2119>must</rfc2119> be a non-negative integer.</p>
                     <p>The <code>$offset</code> is zero based.</p>
                     <p>The binary representation is expected to correspond with that of the IEEE
                        double-precision 64-bit floating point type <bibref ref="ieee754"/>. For
                        more details see <specref ref="floating"/>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.offsetNegative"/> is raised if <code>$offset</code> is
                        negative.</p>
                     <p><bibref ref="error.offsetBeyondEnd"/> is raised if <code>$offset</code> +
                           <code>7</code> (octet-length of <ex:type>xs:double</ex:type> - 1) extends
                        beyond the binary data of <code>$in</code>.</p>
                     <p><bibref ref="error.endianness"/> is raised if the value
                           <code>$octet-order</code> is unrecognized.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="unpack-float">
            <head>bin:unpack-float</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Extract <loc href="http://www.w3.org/TR/xmlschema-2/#float">float</loc>
                        value stored at the particular offset in binary data.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p><example role="signature">
                           <proto name="unpack-float" return-type="xs:float" isOp="no" prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                              <arg name="offset" type="xs:integer"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="unpack-float" return-type="xs:float" isOp="no" prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                              <arg name="offset" type="xs:integer"/>
                              <arg name="octet-order" type="xs:string"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Most-significant-octet-first number representation is assumed unless the
                           <code>$octet-order</code> parameter is specified. Acceptable values for
                           <code>$octet-order</code> are described in <specref ref="endianness"
                        />.</p>
                     <p>The value of <code>$offset</code>
                        <rfc2119>must</rfc2119> be a non-negative integer.</p>
                     <p>The <code>$offset</code> is zero based.</p>
                     <p>The binary representation is expected to correspond with that of the IEEE
                        single-precision 32-bit floating point type <bibref ref="ieee754"/>. For
                        more details see <specref ref="floating"/>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.offsetNegative"/> is raised if <code>$offset</code> is
                        negative.</p>
                     <p><bibref ref="error.offsetBeyondEnd"/> is raised if <code>$offset</code> +
                           <code>3</code> (octet-length of <ex:type>xs:float</ex:type> - 1) extends
                        beyond the binary data of <code>$in</code>.</p>
                     <p><bibref ref="error.endianness"/> is raised if the value
                           <code>$octet-order</code> is unrecognized.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="unpack-integer">
            <head><phrase diff="del">bin:unpack-signed-integer</phrase><phrase diff="add"
                  >bin:unpack-integer</phrase></head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns a signed integer value represented by the <code>$size</code> octets
                        starting from <code>$offset</code> in the input binary representation.
                        Necessary sign extension is performed (i.e. the result is negative if the
                        high order bit is '1').</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p diff="chg"><example role="signature">
                           <proto name="unpack-integer" return-type="xs:integer" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                              <arg name="offset" type="xs:integer"/>
                              <arg name="size" type="xs:integer"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="unpack-integer" return-type="xs:integer" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                              <arg name="offset" type="xs:integer"/>
                              <arg name="size" type="xs:integer"/>
                              <arg name="octet-order" type="xs:string"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Most-significant-octet-first number representation is assumed unless the
                           <code>$octet-order</code> parameter is specified. Acceptable values for
                           <code>$octet-order</code> are described in <specref ref="endianness"
                        />.</p>
                     <p>The values of <code>$offset</code> and <code>$size</code>
                        <rfc2119>must</rfc2119> be non-negative integers.</p>
                     <p><code>$offset</code> is zero based.</p>
                     <p>Specifying a <code>$size</code> of zero yields the integer
                        <code>0</code>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.offsetNegative"/> is raised if <code>$offset</code> is
                        negative.</p>
                     <p><bibref ref="error.sizeNegative"/> is raised if <code>$size</code> is
                        negative.</p>
                     <p><bibref ref="error.offsetBeyondEnd"/> is raised if <code>$offset</code> +
                           <code>$size</code> - 1 extends beyond the binary data of
                        <code>$in</code>.</p>
                     <p><bibref ref="error.endianness"/> is raised if the value
                           <code>$octet-order</code> is unrecognized.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p>For discussion on integer range see <specref ref="integer"/>.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="unpack-unsigned-integer">
            <head>bin:unpack-unsigned-integer</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns an unsigned integer value represented by the <code>$size</code>
                        octets starting from <code>$offset</code> in the input binary
                        representation.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signatures</label>
                  <def>
                     <p><example role="signature">
                           <proto name="unpack-unsigned-integer" return-type="xs:integer" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                              <arg name="offset" type="xs:integer"/>
                              <arg name="size" type="xs:integer"/>
                           </proto>
                        </example><example role="signature">
                           <proto name="unpack-unsigned-integer" return-type="xs:integer" isOp="no"
                              prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                              <arg name="offset" type="xs:integer"/>
                              <arg name="size" type="xs:integer"/>
                              <arg name="octet-order" type="xs:string"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Most-significant-octet-first number representation is assumed unless the
                           <code>$octet-order</code> parameter is specified. Acceptable values for
                           <code>$octet-order</code> are described in <specref ref="endianness"
                        />.</p>
                     <p>The values of <code>$offset</code> and <code>$size</code>
                        <rfc2119>must</rfc2119> be non-negative integers.</p>
                     <p>The <code>$offset</code> is zero based.</p>
                     <p>Specifying a <code>$size</code> of zero yields the integer
                        <code>0</code>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.offsetNegative"/> is raised if <code>$offset</code> is
                        negative.</p>
                     <p><bibref ref="error.sizeNegative"/> is raised if <code>$size</code> is
                        negative.</p>
                     <p><bibref ref="error.offsetBeyondEnd"/> is raised if <code>$offset</code> +
                           <code>$size</code> - 1 extends beyond the binary data of
                        <code>$in</code>.</p>
                     <p><bibref ref="error.endianness"/> is raised if the value
                           <code>$octet-order</code> is unrecognized.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p>For discussion on integer range see <specref ref="integer"/>.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
      </div1>

      <div1 id="bitwise">
         <head>Bitwise operations</head>
         <div2 id="or">
            <head>bin:or</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the "bitwise or" of two binary arguments.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="or" return-type="xs:base64Binary" isOp="no" prefix="bin">
                              <arg name="a" type="xs:base64Binary"/>
                              <arg name="b" type="xs:base64Binary"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Returns "bitwise or" applied between <code>$a</code> and
                        <code>$b</code>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.differentLengthArguments"/> is raised if the input
                        arguments are of differing length.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="xor">
            <head>bin:xor</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the "bitwise xor" of two binary arguments.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="xor" return-type="xs:base64Binary" isOp="no" prefix="bin">
                              <arg name="a" type="xs:base64Binary"/>
                              <arg name="b" type="xs:base64Binary"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Returns "bitwise exclusive or" applied between <code>$a</code> and
                           <code>$b</code>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.differentLengthArguments"/> is raised if the input
                        arguments are of differing length.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="and">
            <head>bin:and</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the "bitwise and" of two binary arguments.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="and" return-type="xs:base64Binary" isOp="no" prefix="bin">
                              <arg name="a" type="xs:base64Binary"/>
                              <arg name="b" type="xs:base64Binary"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Returns "bitwise and" applied between <code>$a</code> and
                        <code>$b</code>.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Error Conditions</label>
                  <def>
                     <p><bibref ref="error.differentLengthArguments"/> is raised if the input
                        arguments are of differing length.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="not">
            <head>bin:not</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Returns the "bitwise not" of a binary argument.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="not" return-type="xs:base64Binary" isOp="no" prefix="bin">
                              <arg name="in" type="xs:base64Binary"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>Returns "bitwise not" applied to <code>$in</code>.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
         <div2 id="shift">
            <head>bin:shift</head>
            <glist>
               <gitem>
                  <label>Summary</label>
                  <def>
                     <p>Shift bits in binary data.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Signature</label>
                  <def>
                     <p><example role="signature">
                           <proto name="shift" return-type="xs:base64Binary?" isOp="no" prefix="bin">
                              <arg name="in" type="xs:base64Binary?"/>
                              <arg name="by" type="xs:integer"/>
                           </proto>
                        </example></p>
                  </def>
               </gitem>
               <gitem>
                  <label>Rules</label>
                  <def>
                     <p>If <code>$by</code> is positive then bits are shifted <code>$by</code> times
                        to the left.</p>
                     <p>If <code>$by</code> is negative then bits are shifted <code>-$by</code>
                        times to the right.</p>
                     <p>If <code>$by</code> is zero, the result is identical to
                        <code>$in</code>.</p>
                     <p>If <code>|$by|</code> is greater than the bit-length of <code>$in</code>
                        then an all-zeros result, of the same length as <code>$in</code>, is
                        returned.</p>
                     <p>The result always has the same size as <code>$in</code>.</p>
                     <p>The shifting is logical: zeros are placed into discarded bits.</p>
                     <p>If the value of <code>$in</code> is the empty sequence, the function returns
                        an empty sequence.</p>
                  </def>
               </gitem>
               <gitem>
                  <label>Notes</label>
                  <def>
                     <p>Bit shifting across byte boundaries implies 'big-endian' treatment, i.e. the
                        leftmost (high-order) bit when shifted left becomes the low-order bit of the
                        preceding byte.</p>
                  </def>
               </gitem>
            </glist>
         </div2>
      </div1>

   </body>

   <back>
      <div1 id="references">
         <head>References</head>
         <blist>

            <bibl id="asn1" key="ASN.1"> OSI networking and system aspects – Abstract Syntax
               Notation One (ASN.1) – see <loc
                  href="http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf">ASN.1
                  encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding
                  Rules (CER) and Distinguished Encoding Rules (DER) </loc>. ITU-T X.690 (07/2002) </bibl>
            <bibl id="expathfile" key="EXPath File">
               <loc href="http://expath.org/spec/file">File Module</loc>. Christian Grün and
               Matthias Brantner, editors. EXPath Candidate Module. 14 June 2012.</bibl>
            <bibl id="fo30" key="F&amp;O 3.0">
               <loc href="http://www.w3.org/TR/xpath-functions-30/">XPath and XQuery Functions and
                  Operators 3.0</loc>. Michael Kay, editor. W3C Candidate Recommendation 21 May
               2013.</bibl>
            <bibl id="ieee754" key="IEEE 754-1985">IEEE Standard for Binary Floating-Point
               Arithmetic. See <loc
                  href="http://standards.ieee.org/reading/ieee/std_public/description/busarch/754-1985_desc.html"
                  >http://standards.ieee.org/reading/ieee/std_public/description/busarch/754-1985_desc.html</loc></bibl>
            <bibl diff="add" id="qt3" key="QT3">
               <loc href="http://dev.w3.org/2011/QT3-test-suite/">XML Query Test Suite</loc>. W3C 21
               June 2013. </bibl>
            <bibl diff="add" id="tests.binary" key="Test-suite"> The test suite for this module,
               using QT3 format, is in the EXPath repository <loc
                  href="http://github.com/expath/expath-cg/tree/master/tests/qt3/binary"
                  >http://github.com/expath/expath-cg</loc> in the directory
               tests/qt3/binary/</bibl>
            <bibl id="xmlschema1.1" key="XML Schema 1.1 Part 2">
               <loc href="http://www.w3.org/TR/xmlschema11-2/">W3C XML Schema Definition Language
                  (XSD) 1.1 Part 2: Datatypes</loc>. David Peterson et al, editors. W3C
               Recommendation 5 April 2012.</bibl>
         </blist>
      </div1>
      <div1 id="errors">
         <head>Summary of error conditions</head>
         <blist>
            <bibl id="error.differentLengthArguments" key="bin:differing-length-arguments">The
               arguments to a bitwise operation are differing lengths.</bibl>
            <bibl id="error.offsetNegative" key="bin:negative-offset">Attempting to retrieve data
               before the start of a binary data type.</bibl>
            <bibl id="error.offsetBeyondEnd" key="bin:offset-beyond-end">Attempting to retrieve data
               beyond the end of a binary data type.</bibl>
            <bibl id="error.sizeNegative" key="bin:negative-size">Size of binary portion, required
               numeric size or padding is negative.</bibl>
            <bibl id="error.emptySearch" key="bin:empty-search-item">Binary search item is
               empty.</bibl>
            <bibl id="error.largeOctet" key="bin:octet-out-of-range">Attempting to pack binary value
               with octet outside range.</bibl>
            <bibl id="error.nonNumberChar" key="bin:non-numeric-character">Wrong character in binary
               'numeric constructor' string.</bibl>
            <bibl id="error.unknownEncoding" key="bin:unknown-encoding">The specified encoding is
               not supported.</bibl>
            <bibl id="error.encoding" key="bin:decoding-error">Error in decoding string.</bibl>
            <bibl id="error.endianness" key="bin:unknown-significance-order">Unknown octet-order
               value.</bibl>
         </blist>
      </div1>
   </back>
</spec>
